/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * OpenEdusync API
 * API documentation for the OpenEdusy application
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AcademicCalendar,
  AcademicProgram,
  AcademicProgramCriteria,
  AcademicProgramRequirement,
  AcademicTerm,
  AdmissionApplication,
  AdmissionApplicationLog,
  AdmissionApplicationScore,
  AdmissionSchedule,
  AuthCredential,
  Building,
  Campus,
  College,
  Course,
  CourseRequisite,
  CreateAcademicCalendarResponse200,
  CreateAcademicProgramCriteriaResponse200,
  CreateAcademicProgramRequirementResponse200,
  CreateAcademicProgramResponse200,
  CreateAcademicTermResponse200,
  CreateAdmissionApplicationLogResponse200,
  CreateAdmissionApplicationResponse200,
  CreateAdmissionApplicationScoreResponse200,
  CreateAdmissionScheduleResponse200,
  CreateBuildingResponse200,
  CreateCampusResponse200,
  CreateCollegeResponse200,
  CreateCourseRequisiteResponse200,
  CreateCourseResponse200,
  CreateCurriculumDetailResponse200,
  CreateCurriculumResponse200,
  CreateDesignitionResponse200,
  CreateDocumentRequestLogResponse200,
  CreateDocumentRequestResponse200,
  CreateDocumentTypeResponse200,
  CreateEnrollmentLogResponse200,
  CreateEnrollmentResponse200,
  CreateProgramTypeResponse200,
  CreateRequirementResponse200,
  CreateRoomResponse200,
  CreateSchoolYearResponse200,
  CreateSectionResponse200,
  CreateUserResponse200,
  Curriculum,
  CurriculumDetail,
  DeleteAcademicCalendarResponse200,
  DeleteAcademicProgramCriteriaResponse200,
  DeleteAcademicProgramRequirementResponse200,
  DeleteAcademicProgramResponse200,
  DeleteAcademicTermResponse200,
  DeleteAdmissionApplicationLogResponse200,
  DeleteAdmissionApplicationResponse200,
  DeleteAdmissionApplicationScoreResponse200,
  DeleteAdmissionScheduleResponse200,
  DeleteBuildingResponse200,
  DeleteCampusResponse200,
  DeleteCollegeResponse200,
  DeleteCourseRequisiteResponse200,
  DeleteCourseResponse200,
  DeleteCurriculumDetailResponse200,
  DeleteCurriculumResponse200,
  DeleteDesignitionResponse200,
  DeleteDocumentRequestLogResponse200,
  DeleteDocumentRequestResponse200,
  DeleteDocumentTypeResponse200,
  DeleteEnrollmentLogResponse200,
  DeleteEnrollmentResponse200,
  DeleteProgramTypeResponse200,
  DeleteRequirementResponse200,
  DeleteRoomResponse200,
  DeleteSchoolYearResponse200,
  DeleteSectionResponse200,
  DeleteUserResponse200,
  Designition,
  DocumentRequest,
  DocumentRequestLog,
  DocumentType,
  Enrollment,
  EnrollmentLog,
  ForbiddenResponse,
  GenerateSection,
  GetAcademicCalendarPaginatedParams,
  GetAcademicCalendarResponse200,
  GetAcademicProgramCriteriaPaginatedParams,
  GetAcademicProgramCriteriaResponse200,
  GetAcademicProgramPaginatedParams,
  GetAcademicProgramRequirementPaginatedParams,
  GetAcademicProgramRequirementResponse200,
  GetAcademicProgramResponse200,
  GetAcademicTermPaginatedParams,
  GetAcademicTermResponse200,
  GetAdmissionApplicationLogPaginatedParams,
  GetAdmissionApplicationLogResponse200,
  GetAdmissionApplicationPaginatedParams,
  GetAdmissionApplicationResponse200,
  GetAdmissionApplicationScorePaginatedParams,
  GetAdmissionApplicationScoreResponse200,
  GetAdmissionApplicationScoresResponse200,
  GetAdmissionSchedulePaginatedParams,
  GetAdmissionScheduleResponse200,
  GetBuildingPaginatedParams,
  GetBuildingResponse200,
  GetCampusPaginatedParams,
  GetCampusResponse200,
  GetCollegePaginatedParams,
  GetCollegeResponse200,
  GetCoursePaginatedParams,
  GetCourseRequisitePaginatedParams,
  GetCourseRequisiteResponse200,
  GetCourseResponse200,
  GetCurriculumDetailPaginatedParams,
  GetCurriculumDetailResponse200,
  GetCurriculumDetailsResponse200,
  GetCurriculumPaginatedParams,
  GetCurriculumResponse200,
  GetDesignitionPaginatedParams,
  GetDesignitionResponse200,
  GetDocumentRequestLogPaginatedParams,
  GetDocumentRequestLogResponse200,
  GetDocumentRequestPaginatedParams,
  GetDocumentRequestResponse200,
  GetDocumentTypePaginatedParams,
  GetDocumentTypeResponse200,
  GetEnrollmentLogPaginatedParams,
  GetEnrollmentLogResponse200,
  GetEnrollmentPaginatedParams,
  GetEnrollmentResponse200,
  GetEnrollmentsByAcademicProgramIdGroupedByUserParams,
  GetProgramTypePaginatedParams,
  GetProgramTypeResponse200,
  GetRequirementPaginatedParams,
  GetRequirementResponse200,
  GetRoomPaginatedParams,
  GetRoomResponse200,
  GetScholasticFilter200,
  GetScholasticFilterParams,
  GetSchoolYearPaginatedParams,
  GetSchoolYearResponse200,
  GetSectionPaginatedParams,
  GetSectionResponse200,
  GetSectionsResponse200,
  GetUserPaginatedParams,
  GetUserResponse200,
  InternalServerErrorResponse,
  LoginResponse200,
  MultipleCurriculumDetail,
  PaginatedAcademicCalendarResponse200,
  PaginatedAcademicProgramCriteriaResponse200,
  PaginatedAcademicProgramRequirementResponse200,
  PaginatedAcademicProgramResponse200,
  PaginatedAcademicTermResponse200,
  PaginatedAdmissionApplicationLogResponse200,
  PaginatedAdmissionApplicationResponse200,
  PaginatedAdmissionApplicationScoreResponse200,
  PaginatedAdmissionScheduleResponse200,
  PaginatedBuildingResponse200,
  PaginatedCampusResponse200,
  PaginatedCollegeResponse200,
  PaginatedCourseRequisiteResponse200,
  PaginatedCourseResponse200,
  PaginatedCurriculumDetailResponse200,
  PaginatedCurriculumResponse200,
  PaginatedDesignitionResponse200,
  PaginatedDocumentRequestLogResponse200,
  PaginatedDocumentRequestResponse200,
  PaginatedDocumentTypeResponse200,
  PaginatedEnrollmentLogResponse200,
  PaginatedEnrollmentResponse200,
  PaginatedProgramTypeResponse200,
  PaginatedRequirementResponse200,
  PaginatedRoomResponse200,
  PaginatedSchoolYearResponse200,
  PaginatedSectionResponse200,
  PaginatedUserResponse200,
  ProgramType,
  Requirement,
  Room,
  SchoolYear,
  Section,
  SessionResponse200,
  SuccessResponse,
  UnauthenticatedResponse,
  UnauthorizedResponse,
  UpdateAcademicCalendarResponse200,
  UpdateAcademicProgramCriteriaResponse200,
  UpdateAcademicProgramRequirementResponse200,
  UpdateAcademicProgramResponse200,
  UpdateAcademicTermResponse200,
  UpdateAdmissionApplicationLogResponse200,
  UpdateAdmissionApplicationResponse200,
  UpdateAdmissionApplicationScoreResponse200,
  UpdateAdmissionScheduleResponse200,
  UpdateBuildingResponse200,
  UpdateCampusResponse200,
  UpdateCollegeResponse200,
  UpdateCourseRequisiteResponse200,
  UpdateCourseResponse200,
  UpdateCurriculumDetailResponse200,
  UpdateCurriculumResponse200,
  UpdateDesignitionResponse200,
  UpdateDocumentRequestLogResponse200,
  UpdateDocumentRequestResponse200,
  UpdateDocumentTypeResponse200,
  UpdateEnrollmentLogResponse200,
  UpdateEnrollmentResponse200,
  UpdateProgramTypeResponse200,
  UpdateRequirementResponse200,
  UpdateRoomResponse200,
  UpdateSchoolYearResponse200,
  UpdateSectionResponse200,
  UpdateUserResponse200,
  User,
  ValidationErrorResponse
} from './models';

import { fetchData } from './axios';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * Retrieve a paginated list of AcademicCalendar with optional search
 * @summary Get paginated list of AcademicCalendar
 */
export const getAcademicCalendarPaginated = (
    params?: GetAcademicCalendarPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicCalendarPaginatedQueryKey = (params?: GetAcademicCalendarPaginatedParams,) => {
    return [`/api/AcademicCalendar`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicCalendarPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicCalendarPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>> = ({ signal }) => getAcademicCalendarPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicCalendarPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>>
export type GetAcademicCalendarPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAcademicCalendarPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicCalendar
 */

export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicCalendarPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicCalendar with the provided details
 * @summary Create a new AcademicCalendar
 */
export const createAcademicCalendar = (
    academicCalendar: NonReadonly<AcademicCalendar>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicCalendar, signal
    },
      );
    }
  


export const getCreateAcademicCalendarMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicCalendar>>, TError,{data: NonReadonly<AcademicCalendar>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicCalendar>>, TError,{data: NonReadonly<AcademicCalendar>}, TContext> => {

const mutationKey = ['createAcademicCalendar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicCalendar>>, {data: NonReadonly<AcademicCalendar>}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicCalendar(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicCalendar>>>
    export type CreateAcademicCalendarMutationBody = NonReadonly<AcademicCalendar>
    export type CreateAcademicCalendarMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicCalendar
 */
export const useCreateAcademicCalendar = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicCalendar>>, TError,{data: NonReadonly<AcademicCalendar>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicCalendar>>,
        TError,
        {data: NonReadonly<AcademicCalendar>},
        TContext
      > => {

      const mutationOptions = getCreateAcademicCalendarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AcademicCalendar by its ID
 * @summary Get a specific AcademicCalendar
 */
export const getAcademicCalendarById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicCalendarByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicCalendar/${id}`] as const;
    }

    
export const getGetAcademicCalendarByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicCalendarByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicCalendarById>>> = ({ signal }) => getAcademicCalendarById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicCalendarByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicCalendarById>>>
export type GetAcademicCalendarByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicCalendar
 */

export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicCalendarByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AcademicCalendar with the provided details
 * @summary Update a AcademicCalendar
 */
export const updateAcademicCalendar = (
    id: number,
    academicCalendar: NonReadonly<AcademicCalendar>,
 ) => {
      
      
      return fetchData<UpdateAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicCalendar
    },
      );
    }
  


export const getUpdateAcademicCalendarMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicCalendar>>, TError,{id: number;data: NonReadonly<AcademicCalendar>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicCalendar>>, TError,{id: number;data: NonReadonly<AcademicCalendar>}, TContext> => {

const mutationKey = ['updateAcademicCalendar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicCalendar>>, {id: number;data: NonReadonly<AcademicCalendar>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicCalendar(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicCalendar>>>
    export type UpdateAcademicCalendarMutationBody = NonReadonly<AcademicCalendar>
    export type UpdateAcademicCalendarMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicCalendar
 */
export const useUpdateAcademicCalendar = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicCalendar>>, TError,{id: number;data: NonReadonly<AcademicCalendar>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicCalendar>>,
        TError,
        {id: number;data: NonReadonly<AcademicCalendar>},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicCalendarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicCalendar by its ID
 * @summary Delete a AcademicCalendar
 */
export const deleteAcademicCalendar = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicCalendarMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicCalendar>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicCalendar>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicCalendar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicCalendar>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicCalendar(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicCalendar>>>
    
    export type DeleteAcademicCalendarMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicCalendar
 */
export const useDeleteAcademicCalendar = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicCalendar>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicCalendar>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicCalendarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AcademicProgram with optional search
 * @summary Get paginated list of AcademicProgram
 */
export const getAcademicProgramPaginated = (
    params?: GetAcademicProgramPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicProgramResponse200>(
      {url: `/api/AcademicProgram`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicProgramPaginatedQueryKey = (params?: GetAcademicProgramPaginatedParams,) => {
    return [`/api/AcademicProgram`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicProgramPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramPaginated>>> = ({ signal }) => getAcademicProgramPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramPaginated>>>
export type GetAcademicProgramPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAcademicProgramPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicProgram
 */

export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a AcademicProgram by its ID
 * @summary Get a specific AcademicProgram
 */
export const getAcademicProgramById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicProgramByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicProgram/${id}`] as const;
    }

    
export const getGetAcademicProgramByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramById>>> = ({ signal }) => getAcademicProgramById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramById>>>
export type GetAcademicProgramByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicProgram
 */

export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicProgram with the provided details
 * @summary Create a new AcademicProgram
 */
export const createAcademicProgram = (
    academicProgram: AcademicProgram,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicProgram, signal
    },
      );
    }
  


export const getCreateAcademicProgramMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext> => {

const mutationKey = ['createAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicProgram>>, {data: AcademicProgram}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicProgram(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicProgram>>>
    export type CreateAcademicProgramMutationBody = AcademicProgram
    export type CreateAcademicProgramMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicProgram
 */
export const useCreateAcademicProgram = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicProgram>>,
        TError,
        {data: AcademicProgram},
        TContext
      > => {

      const mutationOptions = getCreateAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing AcademicProgram with the provided details
 * @summary Update a AcademicProgram
 */
export const updateAcademicProgram = (
    id: number,
    academicProgram: AcademicProgram,
 ) => {
      
      
      return fetchData<UpdateAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicProgram
    },
      );
    }
  


export const getUpdateAcademicProgramMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext> => {

const mutationKey = ['updateAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicProgram>>, {id: number;data: AcademicProgram}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicProgram(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicProgram>>>
    export type UpdateAcademicProgramMutationBody = AcademicProgram
    export type UpdateAcademicProgramMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicProgram
 */
export const useUpdateAcademicProgram = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicProgram>>,
        TError,
        {id: number;data: AcademicProgram},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicProgram by its ID
 * @summary Delete a AcademicProgram
 */
export const deleteAcademicProgram = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicProgramMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicProgram>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicProgram(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicProgram>>>
    
    export type DeleteAcademicProgramMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicProgram
 */
export const useDeleteAcademicProgram = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicProgram>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AcademicProgramCriteria with optional search
 * @summary Get paginated list of AcademicProgramCriteria
 */
export const getAcademicProgramCriteriaPaginated = (
    params?: GetAcademicProgramCriteriaPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicProgramCriteriaResponse200>(
      {url: `/api/AcademicProgramCriteria`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicProgramCriteriaPaginatedQueryKey = (params?: GetAcademicProgramCriteriaPaginatedParams,) => {
    return [`/api/AcademicProgramCriteria`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicProgramCriteriaPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAcademicProgramCriteriaPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramCriteriaPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>> = ({ signal }) => getAcademicProgramCriteriaPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramCriteriaPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>>
export type GetAcademicProgramCriteriaPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAcademicProgramCriteriaPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAcademicProgramCriteriaPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramCriteriaPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramCriteriaPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramCriteriaPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramCriteriaPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicProgramCriteria
 */

export function useGetAcademicProgramCriteriaPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramCriteriaPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramCriteriaPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicProgramCriteria with the provided details
 * @summary Create a new AcademicProgramCriteria
 */
export const createAcademicProgramCriteria = (
    academicProgramCriteria: AcademicProgramCriteria,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicProgramCriteriaResponse200>(
      {url: `/api/AcademicProgramCriteria`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicProgramCriteria, signal
    },
      );
    }
  


export const getCreateAcademicProgramCriteriaMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgramCriteria>>, TError,{data: AcademicProgramCriteria}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgramCriteria>>, TError,{data: AcademicProgramCriteria}, TContext> => {

const mutationKey = ['createAcademicProgramCriteria'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicProgramCriteria>>, {data: AcademicProgramCriteria}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicProgramCriteria(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicProgramCriteriaMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicProgramCriteria>>>
    export type CreateAcademicProgramCriteriaMutationBody = AcademicProgramCriteria
    export type CreateAcademicProgramCriteriaMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicProgramCriteria
 */
export const useCreateAcademicProgramCriteria = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgramCriteria>>, TError,{data: AcademicProgramCriteria}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicProgramCriteria>>,
        TError,
        {data: AcademicProgramCriteria},
        TContext
      > => {

      const mutationOptions = getCreateAcademicProgramCriteriaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AcademicProgramCriteria by its ID
 * @summary Get a specific AcademicProgramCriteria
 */
export const getAcademicProgramCriteriaById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicProgramCriteriaResponse200>(
      {url: `/api/AcademicProgramCriteria/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicProgramCriteriaByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicProgramCriteria/${id}`] as const;
    }

    
export const getGetAcademicProgramCriteriaByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramCriteriaByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>> = ({ signal }) => getAcademicProgramCriteriaById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramCriteriaByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>>
export type GetAcademicProgramCriteriaByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAcademicProgramCriteriaById<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramCriteriaById<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramCriteriaById<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicProgramCriteria
 */

export function useGetAcademicProgramCriteriaById<TData = Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramCriteriaById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramCriteriaByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AcademicProgramCriteria with the provided details
 * @summary Update a AcademicProgramCriteria
 */
export const updateAcademicProgramCriteria = (
    id: number,
    academicProgramCriteria: AcademicProgramCriteria,
 ) => {
      
      
      return fetchData<UpdateAcademicProgramCriteriaResponse200>(
      {url: `/api/AcademicProgramCriteria/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicProgramCriteria
    },
      );
    }
  


export const getUpdateAcademicProgramCriteriaMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgramCriteria>>, TError,{id: number;data: AcademicProgramCriteria}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgramCriteria>>, TError,{id: number;data: AcademicProgramCriteria}, TContext> => {

const mutationKey = ['updateAcademicProgramCriteria'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicProgramCriteria>>, {id: number;data: AcademicProgramCriteria}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicProgramCriteria(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicProgramCriteriaMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicProgramCriteria>>>
    export type UpdateAcademicProgramCriteriaMutationBody = AcademicProgramCriteria
    export type UpdateAcademicProgramCriteriaMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicProgramCriteria
 */
export const useUpdateAcademicProgramCriteria = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgramCriteria>>, TError,{id: number;data: AcademicProgramCriteria}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicProgramCriteria>>,
        TError,
        {id: number;data: AcademicProgramCriteria},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicProgramCriteriaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicProgramCriteria by its ID
 * @summary Delete a AcademicProgramCriteria
 */
export const deleteAcademicProgramCriteria = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicProgramCriteriaResponse200>(
      {url: `/api/AcademicProgramCriteria/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicProgramCriteriaMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgramCriteria>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgramCriteria>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicProgramCriteria'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicProgramCriteria>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicProgramCriteria(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicProgramCriteriaMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicProgramCriteria>>>
    
    export type DeleteAcademicProgramCriteriaMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicProgramCriteria
 */
export const useDeleteAcademicProgramCriteria = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgramCriteria>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicProgramCriteria>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicProgramCriteriaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AcademicProgramRequirement with optional search
 * @summary Get paginated list of AcademicProgramRequirement
 */
export const getAcademicProgramRequirementPaginated = (
    params?: GetAcademicProgramRequirementPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicProgramRequirementResponse200>(
      {url: `/api/AcademicProgramRequirement`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicProgramRequirementPaginatedQueryKey = (params?: GetAcademicProgramRequirementPaginatedParams,) => {
    return [`/api/AcademicProgramRequirement`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicProgramRequirementPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAcademicProgramRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramRequirementPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>> = ({ signal }) => getAcademicProgramRequirementPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramRequirementPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>>
export type GetAcademicProgramRequirementPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAcademicProgramRequirementPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAcademicProgramRequirementPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramRequirementPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramRequirementPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicProgramRequirement
 */

export function useGetAcademicProgramRequirementPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicProgramRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramRequirementPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicProgramRequirement with the provided details
 * @summary Create a new AcademicProgramRequirement
 */
export const createAcademicProgramRequirement = (
    academicProgramRequirement: NonReadonly<AcademicProgramRequirement>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicProgramRequirementResponse200>(
      {url: `/api/AcademicProgramRequirement`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicProgramRequirement, signal
    },
      );
    }
  


export const getCreateAcademicProgramRequirementMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgramRequirement>>, TError,{data: NonReadonly<AcademicProgramRequirement>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgramRequirement>>, TError,{data: NonReadonly<AcademicProgramRequirement>}, TContext> => {

const mutationKey = ['createAcademicProgramRequirement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicProgramRequirement>>, {data: NonReadonly<AcademicProgramRequirement>}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicProgramRequirement(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicProgramRequirementMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicProgramRequirement>>>
    export type CreateAcademicProgramRequirementMutationBody = NonReadonly<AcademicProgramRequirement>
    export type CreateAcademicProgramRequirementMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicProgramRequirement
 */
export const useCreateAcademicProgramRequirement = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgramRequirement>>, TError,{data: NonReadonly<AcademicProgramRequirement>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicProgramRequirement>>,
        TError,
        {data: NonReadonly<AcademicProgramRequirement>},
        TContext
      > => {

      const mutationOptions = getCreateAcademicProgramRequirementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AcademicProgramRequirement by its ID
 * @summary Get a specific AcademicProgramRequirement
 */
export const getAcademicProgramRequirementById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicProgramRequirementResponse200>(
      {url: `/api/AcademicProgramRequirement/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicProgramRequirementByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicProgramRequirement/${id}`] as const;
    }

    
export const getGetAcademicProgramRequirementByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramRequirementByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>> = ({ signal }) => getAcademicProgramRequirementById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramRequirementByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>>
export type GetAcademicProgramRequirementByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAcademicProgramRequirementById<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramRequirementById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramRequirementById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramRequirementById<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramRequirementById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramRequirementById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramRequirementById<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicProgramRequirement
 */

export function useGetAcademicProgramRequirementById<TData = Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramRequirementById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramRequirementByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AcademicProgramRequirement with the provided details
 * @summary Update a AcademicProgramRequirement
 */
export const updateAcademicProgramRequirement = (
    id: number,
    academicProgramRequirement: NonReadonly<AcademicProgramRequirement>,
 ) => {
      
      
      return fetchData<UpdateAcademicProgramRequirementResponse200>(
      {url: `/api/AcademicProgramRequirement/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicProgramRequirement
    },
      );
    }
  


export const getUpdateAcademicProgramRequirementMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgramRequirement>>, TError,{id: number;data: NonReadonly<AcademicProgramRequirement>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgramRequirement>>, TError,{id: number;data: NonReadonly<AcademicProgramRequirement>}, TContext> => {

const mutationKey = ['updateAcademicProgramRequirement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicProgramRequirement>>, {id: number;data: NonReadonly<AcademicProgramRequirement>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicProgramRequirement(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicProgramRequirementMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicProgramRequirement>>>
    export type UpdateAcademicProgramRequirementMutationBody = NonReadonly<AcademicProgramRequirement>
    export type UpdateAcademicProgramRequirementMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicProgramRequirement
 */
export const useUpdateAcademicProgramRequirement = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgramRequirement>>, TError,{id: number;data: NonReadonly<AcademicProgramRequirement>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicProgramRequirement>>,
        TError,
        {id: number;data: NonReadonly<AcademicProgramRequirement>},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicProgramRequirementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicProgramRequirement by its ID
 * @summary Delete a AcademicProgramRequirement
 */
export const deleteAcademicProgramRequirement = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicProgramRequirementResponse200>(
      {url: `/api/AcademicProgramRequirement/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicProgramRequirementMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgramRequirement>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgramRequirement>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicProgramRequirement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicProgramRequirement>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicProgramRequirement(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicProgramRequirementMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicProgramRequirement>>>
    
    export type DeleteAcademicProgramRequirementMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicProgramRequirement
 */
export const useDeleteAcademicProgramRequirement = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgramRequirement>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicProgramRequirement>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicProgramRequirementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AcademicTerm with optional search
 * @summary Get paginated list of AcademicTerm
 */
export const getAcademicTermPaginated = (
    params?: GetAcademicTermPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicTermResponse200>(
      {url: `/api/AcademicTerm`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicTermPaginatedQueryKey = (params?: GetAcademicTermPaginatedParams,) => {
    return [`/api/AcademicTerm`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicTermPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicTermPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicTermPaginated>>> = ({ signal }) => getAcademicTermPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicTermPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicTermPaginated>>>
export type GetAcademicTermPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAcademicTermPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicTerm
 */

export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicTermPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicTerm with the provided details
 * @summary Create a new AcademicTerm
 */
export const createAcademicTerm = (
    academicTerm: NonReadonly<AcademicTerm>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicTermResponse200>(
      {url: `/api/AcademicTerm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicTerm, signal
    },
      );
    }
  


export const getCreateAcademicTermMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicTerm>>, TError,{data: NonReadonly<AcademicTerm>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicTerm>>, TError,{data: NonReadonly<AcademicTerm>}, TContext> => {

const mutationKey = ['createAcademicTerm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicTerm>>, {data: NonReadonly<AcademicTerm>}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicTerm(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicTermMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicTerm>>>
    export type CreateAcademicTermMutationBody = NonReadonly<AcademicTerm>
    export type CreateAcademicTermMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicTerm
 */
export const useCreateAcademicTerm = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicTerm>>, TError,{data: NonReadonly<AcademicTerm>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicTerm>>,
        TError,
        {data: NonReadonly<AcademicTerm>},
        TContext
      > => {

      const mutationOptions = getCreateAcademicTermMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AcademicTerm by its ID
 * @summary Get a specific AcademicTerm
 */
export const getAcademicTermById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicTermResponse200>(
      {url: `/api/AcademicTerm/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicTermByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicTerm/${id}`] as const;
    }

    
export const getGetAcademicTermByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicTermByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicTermById>>> = ({ signal }) => getAcademicTermById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicTermByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicTermById>>>
export type GetAcademicTermByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicTerm
 */

export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicTermByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AcademicTerm with the provided details
 * @summary Update a AcademicTerm
 */
export const updateAcademicTerm = (
    id: number,
    academicTerm: NonReadonly<AcademicTerm>,
 ) => {
      
      
      return fetchData<UpdateAcademicTermResponse200>(
      {url: `/api/AcademicTerm/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicTerm
    },
      );
    }
  


export const getUpdateAcademicTermMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicTerm>>, TError,{id: number;data: NonReadonly<AcademicTerm>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicTerm>>, TError,{id: number;data: NonReadonly<AcademicTerm>}, TContext> => {

const mutationKey = ['updateAcademicTerm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicTerm>>, {id: number;data: NonReadonly<AcademicTerm>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicTerm(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicTermMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicTerm>>>
    export type UpdateAcademicTermMutationBody = NonReadonly<AcademicTerm>
    export type UpdateAcademicTermMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicTerm
 */
export const useUpdateAcademicTerm = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicTerm>>, TError,{id: number;data: NonReadonly<AcademicTerm>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicTerm>>,
        TError,
        {id: number;data: NonReadonly<AcademicTerm>},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicTermMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicTerm by its ID
 * @summary Delete a AcademicTerm
 */
export const deleteAcademicTerm = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicTermResponse200>(
      {url: `/api/AcademicTerm/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicTermMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicTerm>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicTerm>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicTerm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicTerm>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicTerm(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicTermMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicTerm>>>
    
    export type DeleteAcademicTermMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicTerm
 */
export const useDeleteAcademicTerm = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicTerm>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicTerm>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicTermMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AdmissionApplication with optional search
 * @summary Get paginated list of AdmissionApplication
 */
export const getAdmissionApplicationPaginated = (
    params?: GetAdmissionApplicationPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAdmissionApplicationResponse200>(
      {url: `/api/AdmissionApplication`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAdmissionApplicationPaginatedQueryKey = (params?: GetAdmissionApplicationPaginatedParams,) => {
    return [`/api/AdmissionApplication`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAdmissionApplicationPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAdmissionApplicationPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionApplicationPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>> = ({ signal }) => getAdmissionApplicationPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionApplicationPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>>
export type GetAdmissionApplicationPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAdmissionApplicationPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAdmissionApplicationPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AdmissionApplication
 */

export function useGetAdmissionApplicationPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionApplicationPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AdmissionApplication with the provided details
 * @summary Create a new AdmissionApplication
 */
export const createAdmissionApplication = (
    admissionApplication: NonReadonly<AdmissionApplication>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAdmissionApplicationResponse200>(
      {url: `/api/AdmissionApplication`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplication, signal
    },
      );
    }
  


export const getCreateAdmissionApplicationMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplication>>, TError,{data: NonReadonly<AdmissionApplication>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplication>>, TError,{data: NonReadonly<AdmissionApplication>}, TContext> => {

const mutationKey = ['createAdmissionApplication'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdmissionApplication>>, {data: NonReadonly<AdmissionApplication>}> = (props) => {
          const {data} = props ?? {};

          return  createAdmissionApplication(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdmissionApplicationMutationResult = NonNullable<Awaited<ReturnType<typeof createAdmissionApplication>>>
    export type CreateAdmissionApplicationMutationBody = NonReadonly<AdmissionApplication>
    export type CreateAdmissionApplicationMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AdmissionApplication
 */
export const useCreateAdmissionApplication = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplication>>, TError,{data: NonReadonly<AdmissionApplication>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdmissionApplication>>,
        TError,
        {data: NonReadonly<AdmissionApplication>},
        TContext
      > => {

      const mutationOptions = getCreateAdmissionApplicationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AdmissionApplication by its ID
 * @summary Get a specific AdmissionApplication
 */
export const getAdmissionApplicationById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAdmissionApplicationResponse200>(
      {url: `/api/AdmissionApplication/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAdmissionApplicationByIdQueryKey = (id?: number,) => {
    return [`/api/AdmissionApplication/${id}`] as const;
    }

    
export const getGetAdmissionApplicationByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionApplicationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionApplicationById>>> = ({ signal }) => getAdmissionApplicationById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionApplicationByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionApplicationById>>>
export type GetAdmissionApplicationByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAdmissionApplicationById<TData = Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationById<TData = Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationById<TData = Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AdmissionApplication
 */

export function useGetAdmissionApplicationById<TData = Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionApplicationByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AdmissionApplication with the provided details
 * @summary Update a AdmissionApplication
 */
export const updateAdmissionApplication = (
    id: number,
    admissionApplication: NonReadonly<AdmissionApplication>,
 ) => {
      
      
      return fetchData<UpdateAdmissionApplicationResponse200>(
      {url: `/api/AdmissionApplication/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplication
    },
      );
    }
  


export const getUpdateAdmissionApplicationMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplication>>, TError,{id: number;data: NonReadonly<AdmissionApplication>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplication>>, TError,{id: number;data: NonReadonly<AdmissionApplication>}, TContext> => {

const mutationKey = ['updateAdmissionApplication'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdmissionApplication>>, {id: number;data: NonReadonly<AdmissionApplication>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdmissionApplication(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdmissionApplicationMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdmissionApplication>>>
    export type UpdateAdmissionApplicationMutationBody = NonReadonly<AdmissionApplication>
    export type UpdateAdmissionApplicationMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AdmissionApplication
 */
export const useUpdateAdmissionApplication = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplication>>, TError,{id: number;data: NonReadonly<AdmissionApplication>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdmissionApplication>>,
        TError,
        {id: number;data: NonReadonly<AdmissionApplication>},
        TContext
      > => {

      const mutationOptions = getUpdateAdmissionApplicationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AdmissionApplication by its ID
 * @summary Delete a AdmissionApplication
 */
export const deleteAdmissionApplication = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAdmissionApplicationResponse200>(
      {url: `/api/AdmissionApplication/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdmissionApplicationMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplication>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplication>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAdmissionApplication'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdmissionApplication>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdmissionApplication(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdmissionApplicationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdmissionApplication>>>
    
    export type DeleteAdmissionApplicationMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AdmissionApplication
 */
export const useDeleteAdmissionApplication = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplication>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdmissionApplication>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdmissionApplicationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AdmissionApplicationLog with optional search
 * @summary Get paginated list of AdmissionApplicationLog
 */
export const getAdmissionApplicationLogPaginated = (
    params?: GetAdmissionApplicationLogPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAdmissionApplicationLogResponse200>(
      {url: `/api/AdmissionApplicationLog`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAdmissionApplicationLogPaginatedQueryKey = (params?: GetAdmissionApplicationLogPaginatedParams,) => {
    return [`/api/AdmissionApplicationLog`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAdmissionApplicationLogPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAdmissionApplicationLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionApplicationLogPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>> = ({ signal }) => getAdmissionApplicationLogPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionApplicationLogPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>>
export type GetAdmissionApplicationLogPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAdmissionApplicationLogPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAdmissionApplicationLogPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationLogPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationLogPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AdmissionApplicationLog
 */

export function useGetAdmissionApplicationLogPaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionApplicationLogPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AdmissionApplicationLog with the provided details
 * @summary Create a new AdmissionApplicationLog
 */
export const createAdmissionApplicationLog = (
    admissionApplicationLog: NonReadonly<AdmissionApplicationLog>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAdmissionApplicationLogResponse200>(
      {url: `/api/AdmissionApplicationLog`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplicationLog, signal
    },
      );
    }
  


export const getCreateAdmissionApplicationLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplicationLog>>, TError,{data: NonReadonly<AdmissionApplicationLog>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplicationLog>>, TError,{data: NonReadonly<AdmissionApplicationLog>}, TContext> => {

const mutationKey = ['createAdmissionApplicationLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdmissionApplicationLog>>, {data: NonReadonly<AdmissionApplicationLog>}> = (props) => {
          const {data} = props ?? {};

          return  createAdmissionApplicationLog(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdmissionApplicationLogMutationResult = NonNullable<Awaited<ReturnType<typeof createAdmissionApplicationLog>>>
    export type CreateAdmissionApplicationLogMutationBody = NonReadonly<AdmissionApplicationLog>
    export type CreateAdmissionApplicationLogMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AdmissionApplicationLog
 */
export const useCreateAdmissionApplicationLog = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplicationLog>>, TError,{data: NonReadonly<AdmissionApplicationLog>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdmissionApplicationLog>>,
        TError,
        {data: NonReadonly<AdmissionApplicationLog>},
        TContext
      > => {

      const mutationOptions = getCreateAdmissionApplicationLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AdmissionApplicationLog by its ID
 * @summary Get a specific AdmissionApplicationLog
 */
export const getAdmissionApplicationLogById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAdmissionApplicationLogResponse200>(
      {url: `/api/AdmissionApplicationLog/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAdmissionApplicationLogByIdQueryKey = (id?: number,) => {
    return [`/api/AdmissionApplicationLog/${id}`] as const;
    }

    
export const getGetAdmissionApplicationLogByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionApplicationLogByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>> = ({ signal }) => getAdmissionApplicationLogById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionApplicationLogByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>>
export type GetAdmissionApplicationLogByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAdmissionApplicationLogById<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationLogById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationLogById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationLogById<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationLogById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationLogById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationLogById<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AdmissionApplicationLog
 */

export function useGetAdmissionApplicationLogById<TData = Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationLogById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionApplicationLogByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AdmissionApplicationLog with the provided details
 * @summary Update a AdmissionApplicationLog
 */
export const updateAdmissionApplicationLog = (
    id: number,
    admissionApplicationLog: NonReadonly<AdmissionApplicationLog>,
 ) => {
      
      
      return fetchData<UpdateAdmissionApplicationLogResponse200>(
      {url: `/api/AdmissionApplicationLog/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplicationLog
    },
      );
    }
  


export const getUpdateAdmissionApplicationLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplicationLog>>, TError,{id: number;data: NonReadonly<AdmissionApplicationLog>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplicationLog>>, TError,{id: number;data: NonReadonly<AdmissionApplicationLog>}, TContext> => {

const mutationKey = ['updateAdmissionApplicationLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdmissionApplicationLog>>, {id: number;data: NonReadonly<AdmissionApplicationLog>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdmissionApplicationLog(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdmissionApplicationLogMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdmissionApplicationLog>>>
    export type UpdateAdmissionApplicationLogMutationBody = NonReadonly<AdmissionApplicationLog>
    export type UpdateAdmissionApplicationLogMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AdmissionApplicationLog
 */
export const useUpdateAdmissionApplicationLog = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplicationLog>>, TError,{id: number;data: NonReadonly<AdmissionApplicationLog>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdmissionApplicationLog>>,
        TError,
        {id: number;data: NonReadonly<AdmissionApplicationLog>},
        TContext
      > => {

      const mutationOptions = getUpdateAdmissionApplicationLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AdmissionApplicationLog by its ID
 * @summary Delete a AdmissionApplicationLog
 */
export const deleteAdmissionApplicationLog = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAdmissionApplicationLogResponse200>(
      {url: `/api/AdmissionApplicationLog/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdmissionApplicationLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplicationLog>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplicationLog>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAdmissionApplicationLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdmissionApplicationLog>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdmissionApplicationLog(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdmissionApplicationLogMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdmissionApplicationLog>>>
    
    export type DeleteAdmissionApplicationLogMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AdmissionApplicationLog
 */
export const useDeleteAdmissionApplicationLog = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplicationLog>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdmissionApplicationLog>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdmissionApplicationLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AdmissionApplicationScore with optional search
 * @summary Get paginated list of AdmissionApplicationScore
 */
export const getAdmissionApplicationScorePaginated = (
    params?: GetAdmissionApplicationScorePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAdmissionApplicationScoreResponse200>(
      {url: `/api/AdmissionApplicationScore`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAdmissionApplicationScorePaginatedQueryKey = (params?: GetAdmissionApplicationScorePaginatedParams,) => {
    return [`/api/AdmissionApplicationScore`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAdmissionApplicationScorePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAdmissionApplicationScorePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionApplicationScorePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>> = ({ signal }) => getAdmissionApplicationScorePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionApplicationScorePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>>
export type GetAdmissionApplicationScorePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAdmissionApplicationScorePaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAdmissionApplicationScorePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationScorePaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationScorePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationScorePaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationScorePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AdmissionApplicationScore
 */

export function useGetAdmissionApplicationScorePaginated<TData = Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionApplicationScorePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScorePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionApplicationScorePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AdmissionApplicationScore with the provided details
 * @summary Create a new AdmissionApplicationScore
 */
export const createAdmissionApplicationScore = (
    admissionApplicationScore: NonReadonly<AdmissionApplicationScore>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAdmissionApplicationScoreResponse200>(
      {url: `/api/AdmissionApplicationScore`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplicationScore, signal
    },
      );
    }
  


export const getCreateAdmissionApplicationScoreMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplicationScore>>, TError,{data: NonReadonly<AdmissionApplicationScore>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplicationScore>>, TError,{data: NonReadonly<AdmissionApplicationScore>}, TContext> => {

const mutationKey = ['createAdmissionApplicationScore'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdmissionApplicationScore>>, {data: NonReadonly<AdmissionApplicationScore>}> = (props) => {
          const {data} = props ?? {};

          return  createAdmissionApplicationScore(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdmissionApplicationScoreMutationResult = NonNullable<Awaited<ReturnType<typeof createAdmissionApplicationScore>>>
    export type CreateAdmissionApplicationScoreMutationBody = NonReadonly<AdmissionApplicationScore>
    export type CreateAdmissionApplicationScoreMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AdmissionApplicationScore
 */
export const useCreateAdmissionApplicationScore = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionApplicationScore>>, TError,{data: NonReadonly<AdmissionApplicationScore>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdmissionApplicationScore>>,
        TError,
        {data: NonReadonly<AdmissionApplicationScore>},
        TContext
      > => {

      const mutationOptions = getCreateAdmissionApplicationScoreMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AdmissionApplicationScore by its ID
 * @summary Get a specific AdmissionApplicationScore
 */
export const getAdmissionApplicationScoreById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAdmissionApplicationScoreResponse200>(
      {url: `/api/AdmissionApplicationScore/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAdmissionApplicationScoreByIdQueryKey = (id?: number,) => {
    return [`/api/AdmissionApplicationScore/${id}`] as const;
    }

    
export const getGetAdmissionApplicationScoreByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionApplicationScoreByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>> = ({ signal }) => getAdmissionApplicationScoreById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionApplicationScoreByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>>
export type GetAdmissionApplicationScoreByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAdmissionApplicationScoreById<TData = Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationScoreById<TData = Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionApplicationScoreById<TData = Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AdmissionApplicationScore
 */

export function useGetAdmissionApplicationScoreById<TData = Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionApplicationScoreById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionApplicationScoreByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AdmissionApplicationScore with the provided details
 * @summary Update a AdmissionApplicationScore
 */
export const updateAdmissionApplicationScore = (
    id: number,
    admissionApplicationScore: NonReadonly<AdmissionApplicationScore>,
 ) => {
      
      
      return fetchData<UpdateAdmissionApplicationScoreResponse200>(
      {url: `/api/AdmissionApplicationScore/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplicationScore
    },
      );
    }
  


export const getUpdateAdmissionApplicationScoreMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplicationScore>>, TError,{id: number;data: NonReadonly<AdmissionApplicationScore>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplicationScore>>, TError,{id: number;data: NonReadonly<AdmissionApplicationScore>}, TContext> => {

const mutationKey = ['updateAdmissionApplicationScore'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdmissionApplicationScore>>, {id: number;data: NonReadonly<AdmissionApplicationScore>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdmissionApplicationScore(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdmissionApplicationScoreMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdmissionApplicationScore>>>
    export type UpdateAdmissionApplicationScoreMutationBody = NonReadonly<AdmissionApplicationScore>
    export type UpdateAdmissionApplicationScoreMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AdmissionApplicationScore
 */
export const useUpdateAdmissionApplicationScore = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionApplicationScore>>, TError,{id: number;data: NonReadonly<AdmissionApplicationScore>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdmissionApplicationScore>>,
        TError,
        {id: number;data: NonReadonly<AdmissionApplicationScore>},
        TContext
      > => {

      const mutationOptions = getUpdateAdmissionApplicationScoreMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AdmissionApplicationScore by its ID
 * @summary Delete a AdmissionApplicationScore
 */
export const deleteAdmissionApplicationScore = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAdmissionApplicationScoreResponse200>(
      {url: `/api/AdmissionApplicationScore/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdmissionApplicationScoreMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplicationScore>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplicationScore>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAdmissionApplicationScore'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdmissionApplicationScore>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdmissionApplicationScore(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdmissionApplicationScoreMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdmissionApplicationScore>>>
    
    export type DeleteAdmissionApplicationScoreMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AdmissionApplicationScore
 */
export const useDeleteAdmissionApplicationScore = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionApplicationScore>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdmissionApplicationScore>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdmissionApplicationScoreMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create or update multiple AdmissionApplicationScores with the provided details
 * @summary Create or update multiple AdmissionApplicationScores
 */
export const createOrUpdateMultipleAdmissionApplicationScores = (
    admissionApplicationScore: NonReadonly<AdmissionApplicationScore[]>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAdmissionApplicationScoresResponse200>(
      {url: `/api/AdmissionApplicationScore/createOrUpdateMultiple`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: admissionApplicationScore, signal
    },
      );
    }
  


export const getCreateOrUpdateMultipleAdmissionApplicationScoresMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrUpdateMultipleAdmissionApplicationScores>>, TError,{data: NonReadonly<AdmissionApplicationScore[]>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOrUpdateMultipleAdmissionApplicationScores>>, TError,{data: NonReadonly<AdmissionApplicationScore[]>}, TContext> => {

const mutationKey = ['createOrUpdateMultipleAdmissionApplicationScores'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrUpdateMultipleAdmissionApplicationScores>>, {data: NonReadonly<AdmissionApplicationScore[]>}> = (props) => {
          const {data} = props ?? {};

          return  createOrUpdateMultipleAdmissionApplicationScores(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrUpdateMultipleAdmissionApplicationScoresMutationResult = NonNullable<Awaited<ReturnType<typeof createOrUpdateMultipleAdmissionApplicationScores>>>
    export type CreateOrUpdateMultipleAdmissionApplicationScoresMutationBody = NonReadonly<AdmissionApplicationScore[]>
    export type CreateOrUpdateMultipleAdmissionApplicationScoresMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create or update multiple AdmissionApplicationScores
 */
export const useCreateOrUpdateMultipleAdmissionApplicationScores = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrUpdateMultipleAdmissionApplicationScores>>, TError,{data: NonReadonly<AdmissionApplicationScore[]>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrUpdateMultipleAdmissionApplicationScores>>,
        TError,
        {data: NonReadonly<AdmissionApplicationScore[]>},
        TContext
      > => {

      const mutationOptions = getCreateOrUpdateMultipleAdmissionApplicationScoresMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AdmissionSchedule with optional search
 * @summary Get paginated list of AdmissionSchedule
 */
export const getAdmissionSchedulePaginated = (
    params?: GetAdmissionSchedulePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAdmissionScheduleResponse200>(
      {url: `/api/AdmissionSchedule`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAdmissionSchedulePaginatedQueryKey = (params?: GetAdmissionSchedulePaginatedParams,) => {
    return [`/api/AdmissionSchedule`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAdmissionSchedulePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetAdmissionSchedulePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionSchedulePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>> = ({ signal }) => getAdmissionSchedulePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionSchedulePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>>
export type GetAdmissionSchedulePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetAdmissionSchedulePaginated<TData = Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetAdmissionSchedulePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionSchedulePaginated<TData = Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionSchedulePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionSchedulePaginated<TData = Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionSchedulePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AdmissionSchedule
 */

export function useGetAdmissionSchedulePaginated<TData = Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetAdmissionSchedulePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionSchedulePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionSchedulePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AdmissionSchedule with the provided details
 * @summary Create a new AdmissionSchedule
 */
export const createAdmissionSchedule = (
    admissionSchedule: NonReadonly<AdmissionSchedule>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAdmissionScheduleResponse200>(
      {url: `/api/AdmissionSchedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: admissionSchedule, signal
    },
      );
    }
  


export const getCreateAdmissionScheduleMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionSchedule>>, TError,{data: NonReadonly<AdmissionSchedule>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAdmissionSchedule>>, TError,{data: NonReadonly<AdmissionSchedule>}, TContext> => {

const mutationKey = ['createAdmissionSchedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAdmissionSchedule>>, {data: NonReadonly<AdmissionSchedule>}> = (props) => {
          const {data} = props ?? {};

          return  createAdmissionSchedule(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAdmissionScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof createAdmissionSchedule>>>
    export type CreateAdmissionScheduleMutationBody = NonReadonly<AdmissionSchedule>
    export type CreateAdmissionScheduleMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AdmissionSchedule
 */
export const useCreateAdmissionSchedule = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAdmissionSchedule>>, TError,{data: NonReadonly<AdmissionSchedule>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAdmissionSchedule>>,
        TError,
        {data: NonReadonly<AdmissionSchedule>},
        TContext
      > => {

      const mutationOptions = getCreateAdmissionScheduleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AdmissionSchedule by its ID
 * @summary Get a specific AdmissionSchedule
 */
export const getAdmissionScheduleById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAdmissionScheduleResponse200>(
      {url: `/api/AdmissionSchedule/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAdmissionScheduleByIdQueryKey = (id?: number,) => {
    return [`/api/AdmissionSchedule/${id}`] as const;
    }

    
export const getGetAdmissionScheduleByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdmissionScheduleByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdmissionScheduleById>>> = ({ signal }) => getAdmissionScheduleById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdmissionScheduleByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAdmissionScheduleById>>>
export type GetAdmissionScheduleByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetAdmissionScheduleById<TData = Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionScheduleById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionScheduleById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionScheduleById<TData = Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdmissionScheduleById>>,
          TError,
          Awaited<ReturnType<typeof getAdmissionScheduleById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdmissionScheduleById<TData = Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AdmissionSchedule
 */

export function useGetAdmissionScheduleById<TData = Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdmissionScheduleById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdmissionScheduleByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AdmissionSchedule with the provided details
 * @summary Update a AdmissionSchedule
 */
export const updateAdmissionSchedule = (
    id: number,
    admissionSchedule: NonReadonly<AdmissionSchedule>,
 ) => {
      
      
      return fetchData<UpdateAdmissionScheduleResponse200>(
      {url: `/api/AdmissionSchedule/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: admissionSchedule
    },
      );
    }
  


export const getUpdateAdmissionScheduleMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionSchedule>>, TError,{id: number;data: NonReadonly<AdmissionSchedule>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionSchedule>>, TError,{id: number;data: NonReadonly<AdmissionSchedule>}, TContext> => {

const mutationKey = ['updateAdmissionSchedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAdmissionSchedule>>, {id: number;data: NonReadonly<AdmissionSchedule>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAdmissionSchedule(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAdmissionScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof updateAdmissionSchedule>>>
    export type UpdateAdmissionScheduleMutationBody = NonReadonly<AdmissionSchedule>
    export type UpdateAdmissionScheduleMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AdmissionSchedule
 */
export const useUpdateAdmissionSchedule = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAdmissionSchedule>>, TError,{id: number;data: NonReadonly<AdmissionSchedule>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAdmissionSchedule>>,
        TError,
        {id: number;data: NonReadonly<AdmissionSchedule>},
        TContext
      > => {

      const mutationOptions = getUpdateAdmissionScheduleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AdmissionSchedule by its ID
 * @summary Delete a AdmissionSchedule
 */
export const deleteAdmissionSchedule = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAdmissionScheduleResponse200>(
      {url: `/api/AdmissionSchedule/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdmissionScheduleMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionSchedule>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionSchedule>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAdmissionSchedule'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdmissionSchedule>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAdmissionSchedule(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdmissionScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdmissionSchedule>>>
    
    export type DeleteAdmissionScheduleMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a AdmissionSchedule
 */
export const useDeleteAdmissionSchedule = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdmissionSchedule>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdmissionSchedule>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAdmissionScheduleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Login
 * @summary Login
 */
export const login = (
    authCredential: AuthCredential,
 signal?: AbortSignal
) => {
      
      
      return fetchData<LoginResponse200>(
      {url: `/api/Auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authCredential, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = UnauthenticatedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: AuthCredential}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: AuthCredential}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: AuthCredential}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = AuthCredential
    export type LoginMutationError = UnauthenticatedResponse

    /**
 * @summary Login
 */
export const useLogin = <TError = UnauthenticatedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: AuthCredential}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: AuthCredential},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Logout
 * @summary Logout
 */
export const logout = (
    
 signal?: AbortSignal
) => {
      
      
      return fetchData<SuccessResponse>(
      {url: `/api/Auth/logout`, method: 'POST', signal
    },
      );
    }
  


export const getLogoutMutationOptions = <TError = UnauthenticatedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = UnauthenticatedResponse

    /**
 * @summary Logout
 */
export const useLogout = <TError = UnauthenticatedResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get session
 * @summary Get session
 */
export const getSession = (
    
 signal?: AbortSignal
) => {
      
      
      return fetchData<SessionResponse200>(
      {url: `/api/Auth/session`, method: 'GET', signal
    },
      );
    }
  

export const getGetSessionQueryKey = () => {
    return [`/api/Auth/session`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = UnauthorizedResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = UnauthorizedResponse


export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = UnauthorizedResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = UnauthorizedResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = UnauthorizedResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get session
 */

export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = UnauthorizedResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a paginated list of Building with optional search
 * @summary Get paginated list of Building
 */
export const getBuildingPaginated = (
    params?: GetBuildingPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedBuildingResponse200>(
      {url: `/api/Building`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetBuildingPaginatedQueryKey = (params?: GetBuildingPaginatedParams,) => {
    return [`/api/Building`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBuildingPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBuildingPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBuildingPaginated>>> = ({ signal }) => getBuildingPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBuildingPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getBuildingPaginated>>>
export type GetBuildingPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetBuildingPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingPaginated>>,
          TError,
          Awaited<ReturnType<typeof getBuildingPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingPaginated>>,
          TError,
          Awaited<ReturnType<typeof getBuildingPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Building
 */

export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBuildingPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Building by its ID
 * @summary Get a specific Building
 */
export const getBuildingById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetBuildingResponse200>(
      {url: `/api/Building/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBuildingByIdQueryKey = (id?: number,) => {
    return [`/api/Building/${id}`] as const;
    }

    
export const getGetBuildingByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBuildingById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBuildingByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBuildingById>>> = ({ signal }) => getBuildingById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBuildingByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBuildingById>>>
export type GetBuildingByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingById>>,
          TError,
          Awaited<ReturnType<typeof getBuildingById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingById>>,
          TError,
          Awaited<ReturnType<typeof getBuildingById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Building
 */

export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBuildingByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Building with the provided details
 * @summary Create a new Building
 */
export const createBuilding = (
    building: Building,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateBuildingResponse200>(
      {url: `/api/Building/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: building, signal
    },
      );
    }
  


export const getCreateBuildingMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext> => {

const mutationKey = ['createBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBuilding>>, {data: Building}> = (props) => {
          const {data} = props ?? {};

          return  createBuilding(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof createBuilding>>>
    export type CreateBuildingMutationBody = Building
    export type CreateBuildingMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Building
 */
export const useCreateBuilding = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBuilding>>,
        TError,
        {data: Building},
        TContext
      > => {

      const mutationOptions = getCreateBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Building with the provided details
 * @summary Update a Building
 */
export const updateBuilding = (
    id: number,
    building: Building,
 ) => {
      
      
      return fetchData<UpdateBuildingResponse200>(
      {url: `/api/Building/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: building
    },
      );
    }
  


export const getUpdateBuildingMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext> => {

const mutationKey = ['updateBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBuilding>>, {id: number;data: Building}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBuilding(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof updateBuilding>>>
    export type UpdateBuildingMutationBody = Building
    export type UpdateBuildingMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Building
 */
export const useUpdateBuilding = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBuilding>>,
        TError,
        {id: number;data: Building},
        TContext
      > => {

      const mutationOptions = getUpdateBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Building by its ID
 * @summary Delete a Building
 */
export const deleteBuilding = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteBuildingResponse200>(
      {url: `/api/Building/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBuildingMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBuilding>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBuilding(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBuilding>>>
    
    export type DeleteBuildingMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Building
 */
export const useDeleteBuilding = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBuilding>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Campus with optional search
 * @summary Get paginated list of Campus
 */
export const getCampusPaginated = (
    params?: GetCampusPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCampusResponse200>(
      {url: `/api/Campus`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCampusPaginatedQueryKey = (params?: GetCampusPaginatedParams,) => {
    return [`/api/Campus`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCampusPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCampusPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampusPaginated>>> = ({ signal }) => getCampusPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCampusPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCampusPaginated>>>
export type GetCampusPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetCampusPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCampusPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCampusPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Campus
 */

export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCampusPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Campus by its ID
 * @summary Get a specific Campus
 */
export const getCampusById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCampusResponse200>(
      {url: `/api/Campus/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCampusByIdQueryKey = (id?: number,) => {
    return [`/api/Campus/${id}`] as const;
    }

    
export const getGetCampusByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCampusById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCampusByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampusById>>> = ({ signal }) => getCampusById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCampusByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCampusById>>>
export type GetCampusByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusById>>,
          TError,
          Awaited<ReturnType<typeof getCampusById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusById>>,
          TError,
          Awaited<ReturnType<typeof getCampusById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Campus
 */

export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCampusByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Campus with the provided details
 * @summary Create a new Campus
 */
export const createCampus = (
    campus: Campus,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCampusResponse200>(
      {url: `/api/Campus/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: campus, signal
    },
      );
    }
  


export const getCreateCampusMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext> => {

const mutationKey = ['createCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCampus>>, {data: Campus}> = (props) => {
          const {data} = props ?? {};

          return  createCampus(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCampusMutationResult = NonNullable<Awaited<ReturnType<typeof createCampus>>>
    export type CreateCampusMutationBody = Campus
    export type CreateCampusMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Campus
 */
export const useCreateCampus = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCampus>>,
        TError,
        {data: Campus},
        TContext
      > => {

      const mutationOptions = getCreateCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Campus with the provided details
 * @summary Update a Campus
 */
export const updateCampus = (
    id: number,
    campus: Campus,
 ) => {
      
      
      return fetchData<UpdateCampusResponse200>(
      {url: `/api/Campus/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: campus
    },
      );
    }
  


export const getUpdateCampusMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext> => {

const mutationKey = ['updateCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCampus>>, {id: number;data: Campus}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCampus(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCampusMutationResult = NonNullable<Awaited<ReturnType<typeof updateCampus>>>
    export type UpdateCampusMutationBody = Campus
    export type UpdateCampusMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Campus
 */
export const useUpdateCampus = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCampus>>,
        TError,
        {id: number;data: Campus},
        TContext
      > => {

      const mutationOptions = getUpdateCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Campus by its ID
 * @summary Delete a Campus
 */
export const deleteCampus = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCampusResponse200>(
      {url: `/api/Campus/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCampusMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCampus>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCampus(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCampusMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCampus>>>
    
    export type DeleteCampusMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Campus
 */
export const useDeleteCampus = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCampus>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of College with optional search
 * @summary Get paginated list of College
 */
export const getCollegePaginated = (
    params?: GetCollegePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCollegeResponse200>(
      {url: `/api/College`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCollegePaginatedQueryKey = (params?: GetCollegePaginatedParams,) => {
    return [`/api/College`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCollegePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollegePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollegePaginated>>> = ({ signal }) => getCollegePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCollegePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCollegePaginated>>>
export type GetCollegePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetCollegePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCollegePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCollegePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of College
 */

export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCollegePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a College by its ID
 * @summary Get a specific College
 */
export const getCollegeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCollegeResponse200>(
      {url: `/api/College/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCollegeByIdQueryKey = (id?: number,) => {
    return [`/api/College/${id}`] as const;
    }

    
export const getGetCollegeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCollegeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollegeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollegeById>>> = ({ signal }) => getCollegeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCollegeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCollegeById>>>
export type GetCollegeByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegeById>>,
          TError,
          Awaited<ReturnType<typeof getCollegeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegeById>>,
          TError,
          Awaited<ReturnType<typeof getCollegeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific College
 */

export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCollegeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new College with the provided details
 * @summary Create a new College
 */
export const createCollege = (
    college: College,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCollegeResponse200>(
      {url: `/api/College/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: college, signal
    },
      );
    }
  


export const getCreateCollegeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext> => {

const mutationKey = ['createCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollege>>, {data: College}> = (props) => {
          const {data} = props ?? {};

          return  createCollege(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof createCollege>>>
    export type CreateCollegeMutationBody = College
    export type CreateCollegeMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new College
 */
export const useCreateCollege = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCollege>>,
        TError,
        {data: College},
        TContext
      > => {

      const mutationOptions = getCreateCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing College with the provided details
 * @summary Update a College
 */
export const updateCollege = (
    id: number,
    college: College,
 ) => {
      
      
      return fetchData<UpdateCollegeResponse200>(
      {url: `/api/College/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: college
    },
      );
    }
  


export const getUpdateCollegeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext> => {

const mutationKey = ['updateCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCollege>>, {id: number;data: College}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCollege(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof updateCollege>>>
    export type UpdateCollegeMutationBody = College
    export type UpdateCollegeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a College
 */
export const useUpdateCollege = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCollege>>,
        TError,
        {id: number;data: College},
        TContext
      > => {

      const mutationOptions = getUpdateCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a College by its ID
 * @summary Delete a College
 */
export const deleteCollege = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCollegeResponse200>(
      {url: `/api/College/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCollegeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCollege>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCollege(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCollege>>>
    
    export type DeleteCollegeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a College
 */
export const useDeleteCollege = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCollege>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Course with optional search
 * @summary Get paginated list of Course
 */
export const getCoursePaginated = (
    params?: GetCoursePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCourseResponse200>(
      {url: `/api/Course`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCoursePaginatedQueryKey = (params?: GetCoursePaginatedParams,) => {
    return [`/api/Course`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCoursePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCoursePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoursePaginated>>> = ({ signal }) => getCoursePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCoursePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCoursePaginated>>>
export type GetCoursePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetCoursePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoursePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCoursePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoursePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCoursePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Course
 */

export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCoursePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Course with the provided details
 * @summary Create a new Course
 */
export const createCourse = (
    course: Course,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCourseResponse200>(
      {url: `/api/Course`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: course, signal
    },
      );
    }
  


export const getCreateCourseMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCourse>>, TError,{data: Course}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCourse>>, TError,{data: Course}, TContext> => {

const mutationKey = ['createCourse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCourse>>, {data: Course}> = (props) => {
          const {data} = props ?? {};

          return  createCourse(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCourseMutationResult = NonNullable<Awaited<ReturnType<typeof createCourse>>>
    export type CreateCourseMutationBody = Course
    export type CreateCourseMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Course
 */
export const useCreateCourse = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCourse>>, TError,{data: Course}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCourse>>,
        TError,
        {data: Course},
        TContext
      > => {

      const mutationOptions = getCreateCourseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Course by its ID
 * @summary Get a specific Course
 */
export const getCourseById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCourseResponse200>(
      {url: `/api/Course/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCourseByIdQueryKey = (id?: number,) => {
    return [`/api/Course/${id}`] as const;
    }

    
export const getGetCourseByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCourseById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCourseByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourseById>>> = ({ signal }) => getCourseById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCourseByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCourseById>>>
export type GetCourseByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseById>>,
          TError,
          Awaited<ReturnType<typeof getCourseById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseById>>,
          TError,
          Awaited<ReturnType<typeof getCourseById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Course
 */

export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCourseByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Course with the provided details
 * @summary Update a Course
 */
export const updateCourse = (
    id: number,
    course: Course,
 ) => {
      
      
      return fetchData<UpdateCourseResponse200>(
      {url: `/api/Course/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: course
    },
      );
    }
  


export const getUpdateCourseMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCourse>>, TError,{id: number;data: Course}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCourse>>, TError,{id: number;data: Course}, TContext> => {

const mutationKey = ['updateCourse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCourse>>, {id: number;data: Course}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCourse(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCourseMutationResult = NonNullable<Awaited<ReturnType<typeof updateCourse>>>
    export type UpdateCourseMutationBody = Course
    export type UpdateCourseMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Course
 */
export const useUpdateCourse = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCourse>>, TError,{id: number;data: Course}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCourse>>,
        TError,
        {id: number;data: Course},
        TContext
      > => {

      const mutationOptions = getUpdateCourseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Course by its ID
 * @summary Delete a Course
 */
export const deleteCourse = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCourseResponse200>(
      {url: `/api/Course/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCourseMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCourse>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCourse>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCourse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCourse>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCourse(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCourseMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCourse>>>
    
    export type DeleteCourseMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Course
 */
export const useDeleteCourse = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCourse>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCourse>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCourseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of CourseRequisite with optional search
 * @summary Get paginated list of CourseRequisite
 */
export const getCourseRequisitePaginated = (
    params?: GetCourseRequisitePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCourseRequisiteResponse200>(
      {url: `/api/CourseRequisite`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCourseRequisitePaginatedQueryKey = (params?: GetCourseRequisitePaginatedParams,) => {
    return [`/api/CourseRequisite`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCourseRequisitePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetCourseRequisitePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCourseRequisitePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourseRequisitePaginated>>> = ({ signal }) => getCourseRequisitePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCourseRequisitePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCourseRequisitePaginated>>>
export type GetCourseRequisitePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetCourseRequisitePaginated<TData = Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetCourseRequisitePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseRequisitePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCourseRequisitePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseRequisitePaginated<TData = Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCourseRequisitePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseRequisitePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCourseRequisitePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseRequisitePaginated<TData = Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCourseRequisitePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of CourseRequisite
 */

export function useGetCourseRequisitePaginated<TData = Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCourseRequisitePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisitePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCourseRequisitePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new CourseRequisite with the provided details
 * @summary Create a new CourseRequisite
 */
export const createCourseRequisite = (
    courseRequisite: CourseRequisite,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCourseRequisiteResponse200>(
      {url: `/api/CourseRequisite`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: courseRequisite, signal
    },
      );
    }
  


export const getCreateCourseRequisiteMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCourseRequisite>>, TError,{data: CourseRequisite}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCourseRequisite>>, TError,{data: CourseRequisite}, TContext> => {

const mutationKey = ['createCourseRequisite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCourseRequisite>>, {data: CourseRequisite}> = (props) => {
          const {data} = props ?? {};

          return  createCourseRequisite(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCourseRequisiteMutationResult = NonNullable<Awaited<ReturnType<typeof createCourseRequisite>>>
    export type CreateCourseRequisiteMutationBody = CourseRequisite
    export type CreateCourseRequisiteMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new CourseRequisite
 */
export const useCreateCourseRequisite = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCourseRequisite>>, TError,{data: CourseRequisite}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCourseRequisite>>,
        TError,
        {data: CourseRequisite},
        TContext
      > => {

      const mutationOptions = getCreateCourseRequisiteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a CourseRequisite by its ID
 * @summary Get a specific CourseRequisite
 */
export const getCourseRequisiteById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCourseRequisiteResponse200>(
      {url: `/api/CourseRequisite/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCourseRequisiteByIdQueryKey = (id?: number,) => {
    return [`/api/CourseRequisite/${id}`] as const;
    }

    
export const getGetCourseRequisiteByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCourseRequisiteById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisiteById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCourseRequisiteByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourseRequisiteById>>> = ({ signal }) => getCourseRequisiteById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisiteById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCourseRequisiteByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCourseRequisiteById>>>
export type GetCourseRequisiteByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetCourseRequisiteById<TData = Awaited<ReturnType<typeof getCourseRequisiteById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisiteById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseRequisiteById>>,
          TError,
          Awaited<ReturnType<typeof getCourseRequisiteById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseRequisiteById<TData = Awaited<ReturnType<typeof getCourseRequisiteById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisiteById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseRequisiteById>>,
          TError,
          Awaited<ReturnType<typeof getCourseRequisiteById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseRequisiteById<TData = Awaited<ReturnType<typeof getCourseRequisiteById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisiteById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific CourseRequisite
 */

export function useGetCourseRequisiteById<TData = Awaited<ReturnType<typeof getCourseRequisiteById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseRequisiteById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCourseRequisiteByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing CourseRequisite with the provided details
 * @summary Update a CourseRequisite
 */
export const updateCourseRequisite = (
    id: number,
    courseRequisite: CourseRequisite,
 ) => {
      
      
      return fetchData<UpdateCourseRequisiteResponse200>(
      {url: `/api/CourseRequisite/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: courseRequisite
    },
      );
    }
  


export const getUpdateCourseRequisiteMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCourseRequisite>>, TError,{id: number;data: CourseRequisite}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCourseRequisite>>, TError,{id: number;data: CourseRequisite}, TContext> => {

const mutationKey = ['updateCourseRequisite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCourseRequisite>>, {id: number;data: CourseRequisite}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCourseRequisite(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCourseRequisiteMutationResult = NonNullable<Awaited<ReturnType<typeof updateCourseRequisite>>>
    export type UpdateCourseRequisiteMutationBody = CourseRequisite
    export type UpdateCourseRequisiteMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a CourseRequisite
 */
export const useUpdateCourseRequisite = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCourseRequisite>>, TError,{id: number;data: CourseRequisite}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCourseRequisite>>,
        TError,
        {id: number;data: CourseRequisite},
        TContext
      > => {

      const mutationOptions = getUpdateCourseRequisiteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a CourseRequisite by its ID
 * @summary Delete a CourseRequisite
 */
export const deleteCourseRequisite = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCourseRequisiteResponse200>(
      {url: `/api/CourseRequisite/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCourseRequisiteMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCourseRequisite>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCourseRequisite>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCourseRequisite'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCourseRequisite>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCourseRequisite(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCourseRequisiteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCourseRequisite>>>
    
    export type DeleteCourseRequisiteMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a CourseRequisite
 */
export const useDeleteCourseRequisite = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCourseRequisite>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCourseRequisite>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCourseRequisiteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Curriculum with optional search
 * @summary Get paginated list of Curriculum
 */
export const getCurriculumPaginated = (
    params?: GetCurriculumPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCurriculumResponse200>(
      {url: `/api/Curriculum`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCurriculumPaginatedQueryKey = (params?: GetCurriculumPaginatedParams,) => {
    return [`/api/Curriculum`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCurriculumPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumPaginated>>> = ({ signal }) => getCurriculumPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumPaginated>>>
export type GetCurriculumPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetCurriculumPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Curriculum
 */

export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Curriculum with the provided details
 * @summary Create a new Curriculum
 */
export const createCurriculum = (
    curriculum: NonReadonly<Curriculum>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCurriculumResponse200>(
      {url: `/api/Curriculum`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: curriculum, signal
    },
      );
    }
  


export const getCreateCurriculumMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculum>>, TError,{data: NonReadonly<Curriculum>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCurriculum>>, TError,{data: NonReadonly<Curriculum>}, TContext> => {

const mutationKey = ['createCurriculum'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCurriculum>>, {data: NonReadonly<Curriculum>}> = (props) => {
          const {data} = props ?? {};

          return  createCurriculum(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCurriculumMutationResult = NonNullable<Awaited<ReturnType<typeof createCurriculum>>>
    export type CreateCurriculumMutationBody = NonReadonly<Curriculum>
    export type CreateCurriculumMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Curriculum
 */
export const useCreateCurriculum = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculum>>, TError,{data: NonReadonly<Curriculum>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCurriculum>>,
        TError,
        {data: NonReadonly<Curriculum>},
        TContext
      > => {

      const mutationOptions = getCreateCurriculumMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Curriculum by its ID
 * @summary Get a specific Curriculum
 */
export const getCurriculumById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCurriculumResponse200>(
      {url: `/api/Curriculum/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurriculumByIdQueryKey = (id?: number,) => {
    return [`/api/Curriculum/${id}`] as const;
    }

    
export const getGetCurriculumByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumById>>> = ({ signal }) => getCurriculumById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumById>>>
export type GetCurriculumByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Curriculum
 */

export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Curriculum with the provided details
 * @summary Update a Curriculum
 */
export const updateCurriculum = (
    id: number,
    curriculum: NonReadonly<Curriculum>,
 ) => {
      
      
      return fetchData<UpdateCurriculumResponse200>(
      {url: `/api/Curriculum/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: curriculum
    },
      );
    }
  


export const getUpdateCurriculumMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculum>>, TError,{id: number;data: NonReadonly<Curriculum>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurriculum>>, TError,{id: number;data: NonReadonly<Curriculum>}, TContext> => {

const mutationKey = ['updateCurriculum'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurriculum>>, {id: number;data: NonReadonly<Curriculum>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurriculum(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurriculumMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurriculum>>>
    export type UpdateCurriculumMutationBody = NonReadonly<Curriculum>
    export type UpdateCurriculumMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Curriculum
 */
export const useUpdateCurriculum = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculum>>, TError,{id: number;data: NonReadonly<Curriculum>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurriculum>>,
        TError,
        {id: number;data: NonReadonly<Curriculum>},
        TContext
      > => {

      const mutationOptions = getUpdateCurriculumMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Curriculum by its ID
 * @summary Delete a Curriculum
 */
export const deleteCurriculum = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCurriculumResponse200>(
      {url: `/api/Curriculum/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurriculumMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculum>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculum>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCurriculum'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurriculum>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurriculum(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCurriculumMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurriculum>>>
    
    export type DeleteCurriculumMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Curriculum
 */
export const useDeleteCurriculum = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculum>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCurriculum>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurriculumMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of CurriculumDetail with optional search
 * @summary Get paginated list of CurriculumDetail
 */
export const getCurriculumDetailPaginated = (
    params?: GetCurriculumDetailPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCurriculumDetailPaginatedQueryKey = (params?: GetCurriculumDetailPaginatedParams,) => {
    return [`/api/CurriculumDetail`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCurriculumDetailPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumDetailPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>> = ({ signal }) => getCurriculumDetailPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumDetailPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>>
export type GetCurriculumDetailPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetCurriculumDetailPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of CurriculumDetail
 */

export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumDetailPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new CurriculumDetail with the provided details
 * @summary Create a new CurriculumDetail
 */
export const createCurriculumDetail = (
    curriculumDetail: NonReadonly<CurriculumDetail>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: curriculumDetail, signal
    },
      );
    }
  


export const getCreateCurriculumDetailMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculumDetail>>, TError,{data: NonReadonly<CurriculumDetail>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCurriculumDetail>>, TError,{data: NonReadonly<CurriculumDetail>}, TContext> => {

const mutationKey = ['createCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCurriculumDetail>>, {data: NonReadonly<CurriculumDetail>}> = (props) => {
          const {data} = props ?? {};

          return  createCurriculumDetail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof createCurriculumDetail>>>
    export type CreateCurriculumDetailMutationBody = NonReadonly<CurriculumDetail>
    export type CreateCurriculumDetailMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new CurriculumDetail
 */
export const useCreateCurriculumDetail = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculumDetail>>, TError,{data: NonReadonly<CurriculumDetail>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCurriculumDetail>>,
        TError,
        {data: NonReadonly<CurriculumDetail>},
        TContext
      > => {

      const mutationOptions = getCreateCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a CurriculumDetail by its ID
 * @summary Get a specific CurriculumDetail
 */
export const getCurriculumDetailById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurriculumDetailByIdQueryKey = (id?: number,) => {
    return [`/api/CurriculumDetail/${id}`] as const;
    }

    
export const getGetCurriculumDetailByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumDetailByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumDetailById>>> = ({ signal }) => getCurriculumDetailById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumDetailByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumDetailById>>>
export type GetCurriculumDetailByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific CurriculumDetail
 */

export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumDetailByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing CurriculumDetail with the provided details
 * @summary Update a CurriculumDetail
 */
export const updateCurriculumDetail = (
    id: number,
    curriculumDetail: NonReadonly<CurriculumDetail>,
 ) => {
      
      
      return fetchData<UpdateCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: curriculumDetail
    },
      );
    }
  


export const getUpdateCurriculumDetailMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculumDetail>>, TError,{id: number;data: NonReadonly<CurriculumDetail>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurriculumDetail>>, TError,{id: number;data: NonReadonly<CurriculumDetail>}, TContext> => {

const mutationKey = ['updateCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurriculumDetail>>, {id: number;data: NonReadonly<CurriculumDetail>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurriculumDetail(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurriculumDetail>>>
    export type UpdateCurriculumDetailMutationBody = NonReadonly<CurriculumDetail>
    export type UpdateCurriculumDetailMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a CurriculumDetail
 */
export const useUpdateCurriculumDetail = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculumDetail>>, TError,{id: number;data: NonReadonly<CurriculumDetail>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurriculumDetail>>,
        TError,
        {id: number;data: NonReadonly<CurriculumDetail>},
        TContext
      > => {

      const mutationOptions = getUpdateCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a CurriculumDetail by its ID
 * @summary Delete a CurriculumDetail
 */
export const deleteCurriculumDetail = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurriculumDetailMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculumDetail>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculumDetail>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurriculumDetail>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurriculumDetail(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurriculumDetail>>>
    
    export type DeleteCurriculumDetailMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a CurriculumDetail
 */
export const useDeleteCurriculumDetail = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculumDetail>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCurriculumDetail>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create multiple CurriculumDetail with the provided details
 * @summary Create multiple CurriculumDetail
 */
export const createMultipleCurriculumDetail = (
    multipleCurriculumDetail: MultipleCurriculumDetail,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCurriculumDetailsResponse200>(
      {url: `/api/CurriculumDetail/multiple`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: multipleCurriculumDetail, signal
    },
      );
    }
  


export const getCreateMultipleCurriculumDetailMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMultipleCurriculumDetail>>, TError,{data: MultipleCurriculumDetail}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createMultipleCurriculumDetail>>, TError,{data: MultipleCurriculumDetail}, TContext> => {

const mutationKey = ['createMultipleCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMultipleCurriculumDetail>>, {data: MultipleCurriculumDetail}> = (props) => {
          const {data} = props ?? {};

          return  createMultipleCurriculumDetail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMultipleCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof createMultipleCurriculumDetail>>>
    export type CreateMultipleCurriculumDetailMutationBody = MultipleCurriculumDetail
    export type CreateMultipleCurriculumDetailMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create multiple CurriculumDetail
 */
export const useCreateMultipleCurriculumDetail = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMultipleCurriculumDetail>>, TError,{data: MultipleCurriculumDetail}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createMultipleCurriculumDetail>>,
        TError,
        {data: MultipleCurriculumDetail},
        TContext
      > => {

      const mutationOptions = getCreateMultipleCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Designition with optional search
 * @summary Get paginated list of Designition
 */
export const getDesignitionPaginated = (
    params?: GetDesignitionPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedDesignitionResponse200>(
      {url: `/api/Designition`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDesignitionPaginatedQueryKey = (params?: GetDesignitionPaginatedParams,) => {
    return [`/api/Designition`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDesignitionPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getDesignitionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetDesignitionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDesignitionPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDesignitionPaginated>>> = ({ signal }) => getDesignitionPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDesignitionPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDesignitionPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getDesignitionPaginated>>>
export type GetDesignitionPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetDesignitionPaginated<TData = Awaited<ReturnType<typeof getDesignitionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetDesignitionPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDesignitionPaginated>>,
          TError,
          Awaited<ReturnType<typeof getDesignitionPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDesignitionPaginated<TData = Awaited<ReturnType<typeof getDesignitionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDesignitionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDesignitionPaginated>>,
          TError,
          Awaited<ReturnType<typeof getDesignitionPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDesignitionPaginated<TData = Awaited<ReturnType<typeof getDesignitionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDesignitionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Designition
 */

export function useGetDesignitionPaginated<TData = Awaited<ReturnType<typeof getDesignitionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDesignitionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDesignitionPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Designition with the provided details
 * @summary Create a new Designition
 */
export const createDesignition = (
    designition: Designition,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDesignitionResponse200>(
      {url: `/api/Designition`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: designition, signal
    },
      );
    }
  


export const getCreateDesignitionMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDesignition>>, TError,{data: Designition}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDesignition>>, TError,{data: Designition}, TContext> => {

const mutationKey = ['createDesignition'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDesignition>>, {data: Designition}> = (props) => {
          const {data} = props ?? {};

          return  createDesignition(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDesignitionMutationResult = NonNullable<Awaited<ReturnType<typeof createDesignition>>>
    export type CreateDesignitionMutationBody = Designition
    export type CreateDesignitionMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Designition
 */
export const useCreateDesignition = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDesignition>>, TError,{data: Designition}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDesignition>>,
        TError,
        {data: Designition},
        TContext
      > => {

      const mutationOptions = getCreateDesignitionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Designition by its ID
 * @summary Get a specific Designition
 */
export const getDesignitionById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetDesignitionResponse200>(
      {url: `/api/Designition/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDesignitionByIdQueryKey = (id?: number,) => {
    return [`/api/Designition/${id}`] as const;
    }

    
export const getGetDesignitionByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDesignitionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDesignitionByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDesignitionById>>> = ({ signal }) => getDesignitionById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDesignitionById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDesignitionByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDesignitionById>>>
export type GetDesignitionByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetDesignitionById<TData = Awaited<ReturnType<typeof getDesignitionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDesignitionById>>,
          TError,
          Awaited<ReturnType<typeof getDesignitionById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDesignitionById<TData = Awaited<ReturnType<typeof getDesignitionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDesignitionById>>,
          TError,
          Awaited<ReturnType<typeof getDesignitionById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDesignitionById<TData = Awaited<ReturnType<typeof getDesignitionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Designition
 */

export function useGetDesignitionById<TData = Awaited<ReturnType<typeof getDesignitionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDesignitionById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDesignitionByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Designition with the provided details
 * @summary Update a Designition
 */
export const updateDesignition = (
    id: number,
    designition: Designition,
 ) => {
      
      
      return fetchData<UpdateDesignitionResponse200>(
      {url: `/api/Designition/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: designition
    },
      );
    }
  


export const getUpdateDesignitionMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDesignition>>, TError,{id: number;data: Designition}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDesignition>>, TError,{id: number;data: Designition}, TContext> => {

const mutationKey = ['updateDesignition'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDesignition>>, {id: number;data: Designition}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDesignition(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDesignitionMutationResult = NonNullable<Awaited<ReturnType<typeof updateDesignition>>>
    export type UpdateDesignitionMutationBody = Designition
    export type UpdateDesignitionMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Designition
 */
export const useUpdateDesignition = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDesignition>>, TError,{id: number;data: Designition}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDesignition>>,
        TError,
        {id: number;data: Designition},
        TContext
      > => {

      const mutationOptions = getUpdateDesignitionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Designition by its ID
 * @summary Delete a Designition
 */
export const deleteDesignition = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteDesignitionResponse200>(
      {url: `/api/Designition/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDesignitionMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDesignition>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDesignition>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteDesignition'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDesignition>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDesignition(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDesignitionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDesignition>>>
    
    export type DeleteDesignitionMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Designition
 */
export const useDeleteDesignition = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDesignition>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDesignition>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDesignitionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new Program Chair with the provided details
 * @summary Create a new Program Chair
 */
export const createProgramChair = (
    designition: Designition,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDesignitionResponse200>(
      {url: `/api/Designition/create-program-chair`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: designition, signal
    },
      );
    }
  


export const getCreateProgramChairMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramChair>>, TError,{data: Designition}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createProgramChair>>, TError,{data: Designition}, TContext> => {

const mutationKey = ['createProgramChair'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProgramChair>>, {data: Designition}> = (props) => {
          const {data} = props ?? {};

          return  createProgramChair(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProgramChairMutationResult = NonNullable<Awaited<ReturnType<typeof createProgramChair>>>
    export type CreateProgramChairMutationBody = Designition
    export type CreateProgramChairMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Program Chair
 */
export const useCreateProgramChair = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramChair>>, TError,{data: Designition}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProgramChair>>,
        TError,
        {data: Designition},
        TContext
      > => {

      const mutationOptions = getCreateProgramChairMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new College Dean with the provided details
 * @summary Create a new College Dean
 */
export const createCollegeDean = (
    designition: Designition,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDesignitionResponse200>(
      {url: `/api/Designition/create-college-dean`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: designition, signal
    },
      );
    }
  


export const getCreateCollegeDeanMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollegeDean>>, TError,{data: Designition}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCollegeDean>>, TError,{data: Designition}, TContext> => {

const mutationKey = ['createCollegeDean'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollegeDean>>, {data: Designition}> = (props) => {
          const {data} = props ?? {};

          return  createCollegeDean(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollegeDeanMutationResult = NonNullable<Awaited<ReturnType<typeof createCollegeDean>>>
    export type CreateCollegeDeanMutationBody = Designition
    export type CreateCollegeDeanMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new College Dean
 */
export const useCreateCollegeDean = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollegeDean>>, TError,{data: Designition}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCollegeDean>>,
        TError,
        {data: Designition},
        TContext
      > => {

      const mutationOptions = getCreateCollegeDeanMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Create a new Campus Registrar with the provided details
 * @summary Create a new Campus Registrar
 */
export const createCampusRegistrar = (
    designition: Designition,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDesignitionResponse200>(
      {url: `/api/Designition/create-campus-registrar`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: designition, signal
    },
      );
    }
  


export const getCreateCampusRegistrarMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampusRegistrar>>, TError,{data: Designition}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCampusRegistrar>>, TError,{data: Designition}, TContext> => {

const mutationKey = ['createCampusRegistrar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCampusRegistrar>>, {data: Designition}> = (props) => {
          const {data} = props ?? {};

          return  createCampusRegistrar(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCampusRegistrarMutationResult = NonNullable<Awaited<ReturnType<typeof createCampusRegistrar>>>
    export type CreateCampusRegistrarMutationBody = Designition
    export type CreateCampusRegistrarMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Campus Registrar
 */
export const useCreateCampusRegistrar = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampusRegistrar>>, TError,{data: Designition}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCampusRegistrar>>,
        TError,
        {data: Designition},
        TContext
      > => {

      const mutationOptions = getCreateCampusRegistrarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of DocumentRequest with optional search
 * @summary Get paginated list of DocumentRequest
 */
export const getDocumentRequestPaginated = (
    params?: GetDocumentRequestPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedDocumentRequestResponse200>(
      {url: `/api/DocumentRequest`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDocumentRequestPaginatedQueryKey = (params?: GetDocumentRequestPaginatedParams,) => {
    return [`/api/DocumentRequest`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDocumentRequestPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetDocumentRequestPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentRequestPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentRequestPaginated>>> = ({ signal }) => getDocumentRequestPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentRequestPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentRequestPaginated>>>
export type GetDocumentRequestPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetDocumentRequestPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetDocumentRequestPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestPaginated>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentRequestPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestPaginated>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentRequestPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of DocumentRequest
 */

export function useGetDocumentRequestPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentRequestPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentRequestPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new DocumentRequest with the provided details
 * @summary Create a new DocumentRequest
 */
export const createDocumentRequest = (
    documentRequest: DocumentRequest,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDocumentRequestResponse200>(
      {url: `/api/DocumentRequest`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentRequest, signal
    },
      );
    }
  


export const getCreateDocumentRequestMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentRequest>>, TError,{data: DocumentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDocumentRequest>>, TError,{data: DocumentRequest}, TContext> => {

const mutationKey = ['createDocumentRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDocumentRequest>>, {data: DocumentRequest}> = (props) => {
          const {data} = props ?? {};

          return  createDocumentRequest(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDocumentRequestMutationResult = NonNullable<Awaited<ReturnType<typeof createDocumentRequest>>>
    export type CreateDocumentRequestMutationBody = DocumentRequest
    export type CreateDocumentRequestMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new DocumentRequest
 */
export const useCreateDocumentRequest = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentRequest>>, TError,{data: DocumentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDocumentRequest>>,
        TError,
        {data: DocumentRequest},
        TContext
      > => {

      const mutationOptions = getCreateDocumentRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a DocumentRequest by its ID
 * @summary Get a specific DocumentRequest
 */
export const getDocumentRequestById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetDocumentRequestResponse200>(
      {url: `/api/DocumentRequest/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDocumentRequestByIdQueryKey = (id?: number,) => {
    return [`/api/DocumentRequest/${id}`] as const;
    }

    
export const getGetDocumentRequestByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentRequestById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentRequestByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentRequestById>>> = ({ signal }) => getDocumentRequestById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentRequestByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentRequestById>>>
export type GetDocumentRequestByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetDocumentRequestById<TData = Awaited<ReturnType<typeof getDocumentRequestById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestById>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestById<TData = Awaited<ReturnType<typeof getDocumentRequestById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestById>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestById<TData = Awaited<ReturnType<typeof getDocumentRequestById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific DocumentRequest
 */

export function useGetDocumentRequestById<TData = Awaited<ReturnType<typeof getDocumentRequestById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentRequestByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing DocumentRequest with the provided details
 * @summary Update a DocumentRequest
 */
export const updateDocumentRequest = (
    id: number,
    documentRequest: DocumentRequest,
 ) => {
      
      
      return fetchData<UpdateDocumentRequestResponse200>(
      {url: `/api/DocumentRequest/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: documentRequest
    },
      );
    }
  


export const getUpdateDocumentRequestMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentRequest>>, TError,{id: number;data: DocumentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDocumentRequest>>, TError,{id: number;data: DocumentRequest}, TContext> => {

const mutationKey = ['updateDocumentRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDocumentRequest>>, {id: number;data: DocumentRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDocumentRequest(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDocumentRequestMutationResult = NonNullable<Awaited<ReturnType<typeof updateDocumentRequest>>>
    export type UpdateDocumentRequestMutationBody = DocumentRequest
    export type UpdateDocumentRequestMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a DocumentRequest
 */
export const useUpdateDocumentRequest = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentRequest>>, TError,{id: number;data: DocumentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDocumentRequest>>,
        TError,
        {id: number;data: DocumentRequest},
        TContext
      > => {

      const mutationOptions = getUpdateDocumentRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a DocumentRequest by its ID
 * @summary Delete a DocumentRequest
 */
export const deleteDocumentRequest = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteDocumentRequestResponse200>(
      {url: `/api/DocumentRequest/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDocumentRequestMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentRequest>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentRequest>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteDocumentRequest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocumentRequest>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDocumentRequest(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentRequestMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocumentRequest>>>
    
    export type DeleteDocumentRequestMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a DocumentRequest
 */
export const useDeleteDocumentRequest = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentRequest>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocumentRequest>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of DocumentRequestLog with optional search
 * @summary Get paginated list of DocumentRequestLog
 */
export const getDocumentRequestLogPaginated = (
    params?: GetDocumentRequestLogPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedDocumentRequestLogResponse200>(
      {url: `/api/DocumentRequestLog`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDocumentRequestLogPaginatedQueryKey = (params?: GetDocumentRequestLogPaginatedParams,) => {
    return [`/api/DocumentRequestLog`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDocumentRequestLogPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetDocumentRequestLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentRequestLogPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>> = ({ signal }) => getDocumentRequestLogPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentRequestLogPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>>
export type GetDocumentRequestLogPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetDocumentRequestLogPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetDocumentRequestLogPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestLogPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentRequestLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestLogPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentRequestLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of DocumentRequestLog
 */

export function useGetDocumentRequestLogPaginated<TData = Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentRequestLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentRequestLogPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new DocumentRequestLog with the provided details
 * @summary Create a new DocumentRequestLog
 */
export const createDocumentRequestLog = (
    documentRequestLog: NonReadonly<DocumentRequestLog>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDocumentRequestLogResponse200>(
      {url: `/api/DocumentRequestLog`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentRequestLog, signal
    },
      );
    }
  


export const getCreateDocumentRequestLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentRequestLog>>, TError,{data: NonReadonly<DocumentRequestLog>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDocumentRequestLog>>, TError,{data: NonReadonly<DocumentRequestLog>}, TContext> => {

const mutationKey = ['createDocumentRequestLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDocumentRequestLog>>, {data: NonReadonly<DocumentRequestLog>}> = (props) => {
          const {data} = props ?? {};

          return  createDocumentRequestLog(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDocumentRequestLogMutationResult = NonNullable<Awaited<ReturnType<typeof createDocumentRequestLog>>>
    export type CreateDocumentRequestLogMutationBody = NonReadonly<DocumentRequestLog>
    export type CreateDocumentRequestLogMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new DocumentRequestLog
 */
export const useCreateDocumentRequestLog = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentRequestLog>>, TError,{data: NonReadonly<DocumentRequestLog>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDocumentRequestLog>>,
        TError,
        {data: NonReadonly<DocumentRequestLog>},
        TContext
      > => {

      const mutationOptions = getCreateDocumentRequestLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a DocumentRequestLog by its ID
 * @summary Get a specific DocumentRequestLog
 */
export const getDocumentRequestLogById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetDocumentRequestLogResponse200>(
      {url: `/api/DocumentRequestLog/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDocumentRequestLogByIdQueryKey = (id?: number,) => {
    return [`/api/DocumentRequestLog/${id}`] as const;
    }

    
export const getGetDocumentRequestLogByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentRequestLogByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentRequestLogById>>> = ({ signal }) => getDocumentRequestLogById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentRequestLogByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentRequestLogById>>>
export type GetDocumentRequestLogByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetDocumentRequestLogById<TData = Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestLogById>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestLogById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestLogById<TData = Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentRequestLogById>>,
          TError,
          Awaited<ReturnType<typeof getDocumentRequestLogById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentRequestLogById<TData = Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific DocumentRequestLog
 */

export function useGetDocumentRequestLogById<TData = Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentRequestLogById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentRequestLogByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing DocumentRequestLog with the provided details
 * @summary Update a DocumentRequestLog
 */
export const updateDocumentRequestLog = (
    id: number,
    documentRequestLog: NonReadonly<DocumentRequestLog>,
 ) => {
      
      
      return fetchData<UpdateDocumentRequestLogResponse200>(
      {url: `/api/DocumentRequestLog/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: documentRequestLog
    },
      );
    }
  


export const getUpdateDocumentRequestLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentRequestLog>>, TError,{id: number;data: NonReadonly<DocumentRequestLog>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDocumentRequestLog>>, TError,{id: number;data: NonReadonly<DocumentRequestLog>}, TContext> => {

const mutationKey = ['updateDocumentRequestLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDocumentRequestLog>>, {id: number;data: NonReadonly<DocumentRequestLog>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDocumentRequestLog(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDocumentRequestLogMutationResult = NonNullable<Awaited<ReturnType<typeof updateDocumentRequestLog>>>
    export type UpdateDocumentRequestLogMutationBody = NonReadonly<DocumentRequestLog>
    export type UpdateDocumentRequestLogMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a DocumentRequestLog
 */
export const useUpdateDocumentRequestLog = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentRequestLog>>, TError,{id: number;data: NonReadonly<DocumentRequestLog>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDocumentRequestLog>>,
        TError,
        {id: number;data: NonReadonly<DocumentRequestLog>},
        TContext
      > => {

      const mutationOptions = getUpdateDocumentRequestLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a DocumentRequestLog by its ID
 * @summary Delete a DocumentRequestLog
 */
export const deleteDocumentRequestLog = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteDocumentRequestLogResponse200>(
      {url: `/api/DocumentRequestLog/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDocumentRequestLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentRequestLog>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentRequestLog>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteDocumentRequestLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocumentRequestLog>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDocumentRequestLog(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentRequestLogMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocumentRequestLog>>>
    
    export type DeleteDocumentRequestLogMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a DocumentRequestLog
 */
export const useDeleteDocumentRequestLog = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentRequestLog>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocumentRequestLog>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentRequestLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of DocumentType with optional search
 * @summary Get paginated list of DocumentType
 */
export const getDocumentTypePaginated = (
    params?: GetDocumentTypePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedDocumentTypeResponse200>(
      {url: `/api/DocumentType`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDocumentTypePaginatedQueryKey = (params?: GetDocumentTypePaginatedParams,) => {
    return [`/api/DocumentType`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDocumentTypePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetDocumentTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentTypePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentTypePaginated>>> = ({ signal }) => getDocumentTypePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentTypePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentTypePaginated>>>
export type GetDocumentTypePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetDocumentTypePaginated<TData = Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetDocumentTypePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getDocumentTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentTypePaginated<TData = Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getDocumentTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentTypePaginated<TData = Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of DocumentType
 */

export function useGetDocumentTypePaginated<TData = Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetDocumentTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentTypePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new DocumentType with the provided details
 * @summary Create a new DocumentType
 */
export const createDocumentType = (
    documentType: DocumentType,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateDocumentTypeResponse200>(
      {url: `/api/DocumentType`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentType, signal
    },
      );
    }
  


export const getCreateDocumentTypeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentType>>, TError,{data: DocumentType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDocumentType>>, TError,{data: DocumentType}, TContext> => {

const mutationKey = ['createDocumentType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDocumentType>>, {data: DocumentType}> = (props) => {
          const {data} = props ?? {};

          return  createDocumentType(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDocumentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createDocumentType>>>
    export type CreateDocumentTypeMutationBody = DocumentType
    export type CreateDocumentTypeMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new DocumentType
 */
export const useCreateDocumentType = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentType>>, TError,{data: DocumentType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDocumentType>>,
        TError,
        {data: DocumentType},
        TContext
      > => {

      const mutationOptions = getCreateDocumentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a DocumentType by its ID
 * @summary Get a specific DocumentType
 */
export const getDocumentTypeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetDocumentTypeResponse200>(
      {url: `/api/DocumentType/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDocumentTypeByIdQueryKey = (id?: number,) => {
    return [`/api/DocumentType/${id}`] as const;
    }

    
export const getGetDocumentTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentTypeById>>> = ({ signal }) => getDocumentTypeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentTypeById>>>
export type GetDocumentTypeByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetDocumentTypeById<TData = Awaited<ReturnType<typeof getDocumentTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDocumentTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentTypeById<TData = Awaited<ReturnType<typeof getDocumentTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentTypeById>>,
          TError,
          Awaited<ReturnType<typeof getDocumentTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentTypeById<TData = Awaited<ReturnType<typeof getDocumentTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific DocumentType
 */

export function useGetDocumentTypeById<TData = Awaited<ReturnType<typeof getDocumentTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing DocumentType with the provided details
 * @summary Update a DocumentType
 */
export const updateDocumentType = (
    id: number,
    documentType: DocumentType,
 ) => {
      
      
      return fetchData<UpdateDocumentTypeResponse200>(
      {url: `/api/DocumentType/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: documentType
    },
      );
    }
  


export const getUpdateDocumentTypeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentType>>, TError,{id: number;data: DocumentType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDocumentType>>, TError,{id: number;data: DocumentType}, TContext> => {

const mutationKey = ['updateDocumentType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDocumentType>>, {id: number;data: DocumentType}> = (props) => {
          const {id,data} = props ?? {};

          return  updateDocumentType(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDocumentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateDocumentType>>>
    export type UpdateDocumentTypeMutationBody = DocumentType
    export type UpdateDocumentTypeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a DocumentType
 */
export const useUpdateDocumentType = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentType>>, TError,{id: number;data: DocumentType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDocumentType>>,
        TError,
        {id: number;data: DocumentType},
        TContext
      > => {

      const mutationOptions = getUpdateDocumentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a DocumentType by its ID
 * @summary Delete a DocumentType
 */
export const deleteDocumentType = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteDocumentTypeResponse200>(
      {url: `/api/DocumentType/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDocumentTypeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentType>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentType>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteDocumentType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocumentType>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteDocumentType(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocumentType>>>
    
    export type DeleteDocumentTypeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a DocumentType
 */
export const useDeleteDocumentType = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentType>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocumentType>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Enrollment with optional search
 * @summary Get paginated list of Enrollment
 */
export const getEnrollmentPaginated = (
    params?: GetEnrollmentPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedEnrollmentResponse200>(
      {url: `/api/Enrollment`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetEnrollmentPaginatedQueryKey = (params?: GetEnrollmentPaginatedParams,) => {
    return [`/api/Enrollment`, ...(params ? [params]: [])] as const;
    }

    
export const getGetEnrollmentPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetEnrollmentPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnrollmentPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnrollmentPaginated>>> = ({ signal }) => getEnrollmentPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnrollmentPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getEnrollmentPaginated>>>
export type GetEnrollmentPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetEnrollmentPaginated<TData = Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetEnrollmentPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentPaginated>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentPaginated<TData = Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetEnrollmentPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentPaginated>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentPaginated<TData = Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetEnrollmentPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Enrollment
 */

export function useGetEnrollmentPaginated<TData = Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetEnrollmentPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnrollmentPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Enrollment with the provided details
 * @summary Create a new Enrollment
 */
export const createEnrollment = (
    enrollment: NonReadonly<Enrollment>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateEnrollmentResponse200>(
      {url: `/api/Enrollment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enrollment, signal
    },
      );
    }
  


export const getCreateEnrollmentMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnrollment>>, TError,{data: NonReadonly<Enrollment>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEnrollment>>, TError,{data: NonReadonly<Enrollment>}, TContext> => {

const mutationKey = ['createEnrollment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEnrollment>>, {data: NonReadonly<Enrollment>}> = (props) => {
          const {data} = props ?? {};

          return  createEnrollment(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEnrollmentMutationResult = NonNullable<Awaited<ReturnType<typeof createEnrollment>>>
    export type CreateEnrollmentMutationBody = NonReadonly<Enrollment>
    export type CreateEnrollmentMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Enrollment
 */
export const useCreateEnrollment = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnrollment>>, TError,{data: NonReadonly<Enrollment>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEnrollment>>,
        TError,
        {data: NonReadonly<Enrollment>},
        TContext
      > => {

      const mutationOptions = getCreateEnrollmentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a scholastic filter
 * @summary Get scholastic filter
 */
export const getScholasticFilter = (
    academicProgramId: number,
    params?: GetScholasticFilterParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetScholasticFilter200>(
      {url: `/api/Enrollment/academic-program/scholastic-filter/${academicProgramId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetScholasticFilterQueryKey = (academicProgramId?: number,
    params?: GetScholasticFilterParams,) => {
    return [`/api/Enrollment/academic-program/scholastic-filter/${academicProgramId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetScholasticFilterQueryOptions = <TData = Awaited<ReturnType<typeof getScholasticFilter>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(academicProgramId: number,
    params?: GetScholasticFilterParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScholasticFilter>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetScholasticFilterQueryKey(academicProgramId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getScholasticFilter>>> = ({ signal }) => getScholasticFilter(academicProgramId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(academicProgramId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getScholasticFilter>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetScholasticFilterQueryResult = NonNullable<Awaited<ReturnType<typeof getScholasticFilter>>>
export type GetScholasticFilterQueryError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse


export function useGetScholasticFilter<TData = Awaited<ReturnType<typeof getScholasticFilter>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params: undefined |  GetScholasticFilterParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScholasticFilter>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScholasticFilter>>,
          TError,
          Awaited<ReturnType<typeof getScholasticFilter>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScholasticFilter<TData = Awaited<ReturnType<typeof getScholasticFilter>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params?: GetScholasticFilterParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScholasticFilter>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScholasticFilter>>,
          TError,
          Awaited<ReturnType<typeof getScholasticFilter>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScholasticFilter<TData = Awaited<ReturnType<typeof getScholasticFilter>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params?: GetScholasticFilterParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScholasticFilter>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get scholastic filter
 */

export function useGetScholasticFilter<TData = Awaited<ReturnType<typeof getScholasticFilter>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params?: GetScholasticFilterParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScholasticFilter>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetScholasticFilterQueryOptions(academicProgramId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a paginated list of Enrollment by Academic Program ID
 * @summary Get paginated list of Enrollment by Academic Program ID
 */
export const getEnrollmentsByAcademicProgramIdGroupedByUser = (
    academicProgramId: number,
    params?: GetEnrollmentsByAcademicProgramIdGroupedByUserParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedEnrollmentResponse200>(
      {url: `/api/Enrollment/academic-program/grouped-by-user-name/${academicProgramId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetEnrollmentsByAcademicProgramIdGroupedByUserQueryKey = (academicProgramId?: number,
    params?: GetEnrollmentsByAcademicProgramIdGroupedByUserParams,) => {
    return [`/api/Enrollment/academic-program/grouped-by-user-name/${academicProgramId}`, ...(params ? [params]: [])] as const;
    }

    
export const getGetEnrollmentsByAcademicProgramIdGroupedByUserQueryOptions = <TData = Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(academicProgramId: number,
    params?: GetEnrollmentsByAcademicProgramIdGroupedByUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnrollmentsByAcademicProgramIdGroupedByUserQueryKey(academicProgramId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>> = ({ signal }) => getEnrollmentsByAcademicProgramIdGroupedByUser(academicProgramId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(academicProgramId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnrollmentsByAcademicProgramIdGroupedByUserQueryResult = NonNullable<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>>
export type GetEnrollmentsByAcademicProgramIdGroupedByUserQueryError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse


export function useGetEnrollmentsByAcademicProgramIdGroupedByUser<TData = Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params: undefined |  GetEnrollmentsByAcademicProgramIdGroupedByUserParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentsByAcademicProgramIdGroupedByUser<TData = Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params?: GetEnrollmentsByAcademicProgramIdGroupedByUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentsByAcademicProgramIdGroupedByUser<TData = Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params?: GetEnrollmentsByAcademicProgramIdGroupedByUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Enrollment by Academic Program ID
 */

export function useGetEnrollmentsByAcademicProgramIdGroupedByUser<TData = Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse>(
 academicProgramId: number,
    params?: GetEnrollmentsByAcademicProgramIdGroupedByUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentsByAcademicProgramIdGroupedByUser>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnrollmentsByAcademicProgramIdGroupedByUserQueryOptions(academicProgramId,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Enrollment by its ID
 * @summary Get a specific Enrollment
 */
export const getEnrollmentById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetEnrollmentResponse200>(
      {url: `/api/Enrollment/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEnrollmentByIdQueryKey = (id?: number,) => {
    return [`/api/Enrollment/${id}`] as const;
    }

    
export const getGetEnrollmentByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnrollmentById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnrollmentByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnrollmentById>>> = ({ signal }) => getEnrollmentById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnrollmentByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnrollmentById>>>
export type GetEnrollmentByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetEnrollmentById<TData = Awaited<ReturnType<typeof getEnrollmentById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentById>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentById<TData = Awaited<ReturnType<typeof getEnrollmentById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentById>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentById<TData = Awaited<ReturnType<typeof getEnrollmentById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Enrollment
 */

export function useGetEnrollmentById<TData = Awaited<ReturnType<typeof getEnrollmentById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnrollmentByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Enrollment with the provided details
 * @summary Update a Enrollment
 */
export const updateEnrollment = (
    id: number,
    enrollment: NonReadonly<Enrollment>,
 ) => {
      
      
      return fetchData<UpdateEnrollmentResponse200>(
      {url: `/api/Enrollment/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: enrollment
    },
      );
    }
  


export const getUpdateEnrollmentMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEnrollment>>, TError,{id: number;data: NonReadonly<Enrollment>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEnrollment>>, TError,{id: number;data: NonReadonly<Enrollment>}, TContext> => {

const mutationKey = ['updateEnrollment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEnrollment>>, {id: number;data: NonReadonly<Enrollment>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEnrollment(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEnrollmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateEnrollment>>>
    export type UpdateEnrollmentMutationBody = NonReadonly<Enrollment>
    export type UpdateEnrollmentMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Enrollment
 */
export const useUpdateEnrollment = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEnrollment>>, TError,{id: number;data: NonReadonly<Enrollment>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateEnrollment>>,
        TError,
        {id: number;data: NonReadonly<Enrollment>},
        TContext
      > => {

      const mutationOptions = getUpdateEnrollmentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Enrollment by its ID
 * @summary Delete a Enrollment
 */
export const deleteEnrollment = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteEnrollmentResponse200>(
      {url: `/api/Enrollment/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEnrollmentMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnrollment>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEnrollment>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteEnrollment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEnrollment>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEnrollment(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEnrollmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEnrollment>>>
    
    export type DeleteEnrollmentMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Enrollment
 */
export const useDeleteEnrollment = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnrollment>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEnrollment>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteEnrollmentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Enroll a user in a section with the provided details
 * @summary Enroll a user in a section
 */
export const enrollUser = (
    enrollment: NonReadonly<Enrollment[]>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateEnrollmentResponse200>(
      {url: `/api/Enrollment/enroll`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enrollment, signal
    },
      );
    }
  


export const getEnrollUserMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enrollUser>>, TError,{data: NonReadonly<Enrollment[]>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof enrollUser>>, TError,{data: NonReadonly<Enrollment[]>}, TContext> => {

const mutationKey = ['enrollUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enrollUser>>, {data: NonReadonly<Enrollment[]>}> = (props) => {
          const {data} = props ?? {};

          return  enrollUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnrollUserMutationResult = NonNullable<Awaited<ReturnType<typeof enrollUser>>>
    export type EnrollUserMutationBody = NonReadonly<Enrollment[]>
    export type EnrollUserMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Enroll a user in a section
 */
export const useEnrollUser = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enrollUser>>, TError,{data: NonReadonly<Enrollment[]>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enrollUser>>,
        TError,
        {data: NonReadonly<Enrollment[]>},
        TContext
      > => {

      const mutationOptions = getEnrollUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of EnrollmentLog with optional search
 * @summary Get paginated list of EnrollmentLog
 */
export const getEnrollmentLogPaginated = (
    params?: GetEnrollmentLogPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedEnrollmentLogResponse200>(
      {url: `/api/EnrollmentLog`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetEnrollmentLogPaginatedQueryKey = (params?: GetEnrollmentLogPaginatedParams,) => {
    return [`/api/EnrollmentLog`, ...(params ? [params]: [])] as const;
    }

    
export const getGetEnrollmentLogPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetEnrollmentLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnrollmentLogPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>> = ({ signal }) => getEnrollmentLogPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnrollmentLogPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>>
export type GetEnrollmentLogPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetEnrollmentLogPaginated<TData = Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetEnrollmentLogPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentLogPaginated>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentLogPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentLogPaginated<TData = Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetEnrollmentLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentLogPaginated>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentLogPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentLogPaginated<TData = Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetEnrollmentLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of EnrollmentLog
 */

export function useGetEnrollmentLogPaginated<TData = Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetEnrollmentLogPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnrollmentLogPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new EnrollmentLog with the provided details
 * @summary Create a new EnrollmentLog
 */
export const createEnrollmentLog = (
    enrollmentLog: NonReadonly<EnrollmentLog>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateEnrollmentLogResponse200>(
      {url: `/api/EnrollmentLog`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enrollmentLog, signal
    },
      );
    }
  


export const getCreateEnrollmentLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnrollmentLog>>, TError,{data: NonReadonly<EnrollmentLog>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEnrollmentLog>>, TError,{data: NonReadonly<EnrollmentLog>}, TContext> => {

const mutationKey = ['createEnrollmentLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEnrollmentLog>>, {data: NonReadonly<EnrollmentLog>}> = (props) => {
          const {data} = props ?? {};

          return  createEnrollmentLog(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEnrollmentLogMutationResult = NonNullable<Awaited<ReturnType<typeof createEnrollmentLog>>>
    export type CreateEnrollmentLogMutationBody = NonReadonly<EnrollmentLog>
    export type CreateEnrollmentLogMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new EnrollmentLog
 */
export const useCreateEnrollmentLog = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEnrollmentLog>>, TError,{data: NonReadonly<EnrollmentLog>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEnrollmentLog>>,
        TError,
        {data: NonReadonly<EnrollmentLog>},
        TContext
      > => {

      const mutationOptions = getCreateEnrollmentLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a EnrollmentLog by its ID
 * @summary Get a specific EnrollmentLog
 */
export const getEnrollmentLogById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetEnrollmentLogResponse200>(
      {url: `/api/EnrollmentLog/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetEnrollmentLogByIdQueryKey = (id?: number,) => {
    return [`/api/EnrollmentLog/${id}`] as const;
    }

    
export const getGetEnrollmentLogByIdQueryOptions = <TData = Awaited<ReturnType<typeof getEnrollmentLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEnrollmentLogByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEnrollmentLogById>>> = ({ signal }) => getEnrollmentLogById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEnrollmentLogByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getEnrollmentLogById>>>
export type GetEnrollmentLogByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetEnrollmentLogById<TData = Awaited<ReturnType<typeof getEnrollmentLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentLogById>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentLogById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentLogById<TData = Awaited<ReturnType<typeof getEnrollmentLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEnrollmentLogById>>,
          TError,
          Awaited<ReturnType<typeof getEnrollmentLogById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEnrollmentLogById<TData = Awaited<ReturnType<typeof getEnrollmentLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific EnrollmentLog
 */

export function useGetEnrollmentLogById<TData = Awaited<ReturnType<typeof getEnrollmentLogById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEnrollmentLogById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEnrollmentLogByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing EnrollmentLog with the provided details
 * @summary Update a EnrollmentLog
 */
export const updateEnrollmentLog = (
    id: number,
    enrollmentLog: NonReadonly<EnrollmentLog>,
 ) => {
      
      
      return fetchData<UpdateEnrollmentLogResponse200>(
      {url: `/api/EnrollmentLog/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: enrollmentLog
    },
      );
    }
  


export const getUpdateEnrollmentLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEnrollmentLog>>, TError,{id: number;data: NonReadonly<EnrollmentLog>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEnrollmentLog>>, TError,{id: number;data: NonReadonly<EnrollmentLog>}, TContext> => {

const mutationKey = ['updateEnrollmentLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEnrollmentLog>>, {id: number;data: NonReadonly<EnrollmentLog>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateEnrollmentLog(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEnrollmentLogMutationResult = NonNullable<Awaited<ReturnType<typeof updateEnrollmentLog>>>
    export type UpdateEnrollmentLogMutationBody = NonReadonly<EnrollmentLog>
    export type UpdateEnrollmentLogMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a EnrollmentLog
 */
export const useUpdateEnrollmentLog = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEnrollmentLog>>, TError,{id: number;data: NonReadonly<EnrollmentLog>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateEnrollmentLog>>,
        TError,
        {id: number;data: NonReadonly<EnrollmentLog>},
        TContext
      > => {

      const mutationOptions = getUpdateEnrollmentLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a EnrollmentLog by its ID
 * @summary Delete a EnrollmentLog
 */
export const deleteEnrollmentLog = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteEnrollmentLogResponse200>(
      {url: `/api/EnrollmentLog/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEnrollmentLogMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnrollmentLog>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEnrollmentLog>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteEnrollmentLog'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEnrollmentLog>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteEnrollmentLog(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEnrollmentLogMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEnrollmentLog>>>
    
    export type DeleteEnrollmentLogMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a EnrollmentLog
 */
export const useDeleteEnrollmentLog = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEnrollmentLog>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEnrollmentLog>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteEnrollmentLogMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of ProgramType with optional search
 * @summary Get paginated list of ProgramType
 */
export const getProgramTypePaginated = (
    params?: GetProgramTypePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedProgramTypeResponse200>(
      {url: `/api/ProgramType`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetProgramTypePaginatedQueryKey = (params?: GetProgramTypePaginatedParams,) => {
    return [`/api/ProgramType`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProgramTypePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramTypePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramTypePaginated>>> = ({ signal }) => getProgramTypePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramTypePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramTypePaginated>>>
export type GetProgramTypePaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetProgramTypePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of ProgramType
 */

export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramTypePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a ProgramType by its ID
 * @summary Get a specific ProgramType
 */
export const getProgramTypeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetProgramTypeResponse200>(
      {url: `/api/ProgramType/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProgramTypeByIdQueryKey = (id?: number,) => {
    return [`/api/ProgramType/${id}`] as const;
    }

    
export const getGetProgramTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramTypeById>>> = ({ signal }) => getProgramTypeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramTypeById>>>
export type GetProgramTypeByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypeById>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypeById>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific ProgramType
 */

export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new ProgramType with the provided details
 * @summary Create a new ProgramType
 */
export const createProgramType = (
    programType: ProgramType,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateProgramTypeResponse200>(
      {url: `/api/ProgramType/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: programType, signal
    },
      );
    }
  


export const getCreateProgramTypeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext> => {

const mutationKey = ['createProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProgramType>>, {data: ProgramType}> = (props) => {
          const {data} = props ?? {};

          return  createProgramType(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createProgramType>>>
    export type CreateProgramTypeMutationBody = ProgramType
    export type CreateProgramTypeMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new ProgramType
 */
export const useCreateProgramType = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProgramType>>,
        TError,
        {data: ProgramType},
        TContext
      > => {

      const mutationOptions = getCreateProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing ProgramType with the provided details
 * @summary Update a ProgramType
 */
export const updateProgramType = (
    id: number,
    programType: ProgramType,
 ) => {
      
      
      return fetchData<UpdateProgramTypeResponse200>(
      {url: `/api/ProgramType/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: programType
    },
      );
    }
  


export const getUpdateProgramTypeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext> => {

const mutationKey = ['updateProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProgramType>>, {id: number;data: ProgramType}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProgramType(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateProgramType>>>
    export type UpdateProgramTypeMutationBody = ProgramType
    export type UpdateProgramTypeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a ProgramType
 */
export const useUpdateProgramType = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProgramType>>,
        TError,
        {id: number;data: ProgramType},
        TContext
      > => {

      const mutationOptions = getUpdateProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a ProgramType by its ID
 * @summary Delete a ProgramType
 */
export const deleteProgramType = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteProgramTypeResponse200>(
      {url: `/api/ProgramType/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProgramTypeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProgramType>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProgramType(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProgramType>>>
    
    export type DeleteProgramTypeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a ProgramType
 */
export const useDeleteProgramType = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProgramType>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Requirement with optional search
 * @summary Get paginated list of Requirement
 */
export const getRequirementPaginated = (
    params?: GetRequirementPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedRequirementResponse200>(
      {url: `/api/Requirement`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetRequirementPaginatedQueryKey = (params?: GetRequirementPaginatedParams,) => {
    return [`/api/Requirement`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRequirementPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequirementPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequirementPaginated>>> = ({ signal }) => getRequirementPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRequirementPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRequirementPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getRequirementPaginated>>>
export type GetRequirementPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetRequirementPaginated<TData = Awaited<ReturnType<typeof getRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetRequirementPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirementPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRequirementPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementPaginated<TData = Awaited<ReturnType<typeof getRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirementPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRequirementPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementPaginated<TData = Awaited<ReturnType<typeof getRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Requirement
 */

export function useGetRequirementPaginated<TData = Awaited<ReturnType<typeof getRequirementPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetRequirementPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRequirementPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Requirement with the provided details
 * @summary Create a new Requirement
 */
export const createRequirement = (
    requirement: NonReadonly<Requirement>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateRequirementResponse200>(
      {url: `/api/Requirement`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: requirement, signal
    },
      );
    }
  


export const getCreateRequirementMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRequirement>>, TError,{data: NonReadonly<Requirement>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRequirement>>, TError,{data: NonReadonly<Requirement>}, TContext> => {

const mutationKey = ['createRequirement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRequirement>>, {data: NonReadonly<Requirement>}> = (props) => {
          const {data} = props ?? {};

          return  createRequirement(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRequirementMutationResult = NonNullable<Awaited<ReturnType<typeof createRequirement>>>
    export type CreateRequirementMutationBody = NonReadonly<Requirement>
    export type CreateRequirementMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Requirement
 */
export const useCreateRequirement = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRequirement>>, TError,{data: NonReadonly<Requirement>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRequirement>>,
        TError,
        {data: NonReadonly<Requirement>},
        TContext
      > => {

      const mutationOptions = getCreateRequirementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Requirement by its ID
 * @summary Get a specific Requirement
 */
export const getRequirementById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetRequirementResponse200>(
      {url: `/api/Requirement/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetRequirementByIdQueryKey = (id?: number,) => {
    return [`/api/Requirement/${id}`] as const;
    }

    
export const getGetRequirementByIdQueryOptions = <TData = Awaited<ReturnType<typeof getRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRequirementByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRequirementById>>> = ({ signal }) => getRequirementById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRequirementById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRequirementByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRequirementById>>>
export type GetRequirementByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetRequirementById<TData = Awaited<ReturnType<typeof getRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirementById>>,
          TError,
          Awaited<ReturnType<typeof getRequirementById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementById<TData = Awaited<ReturnType<typeof getRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRequirementById>>,
          TError,
          Awaited<ReturnType<typeof getRequirementById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRequirementById<TData = Awaited<ReturnType<typeof getRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Requirement
 */

export function useGetRequirementById<TData = Awaited<ReturnType<typeof getRequirementById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRequirementById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRequirementByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Requirement with the provided details
 * @summary Update a Requirement
 */
export const updateRequirement = (
    id: number,
    requirement: NonReadonly<Requirement>,
 ) => {
      
      
      return fetchData<UpdateRequirementResponse200>(
      {url: `/api/Requirement/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: requirement
    },
      );
    }
  


export const getUpdateRequirementMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequirement>>, TError,{id: number;data: NonReadonly<Requirement>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRequirement>>, TError,{id: number;data: NonReadonly<Requirement>}, TContext> => {

const mutationKey = ['updateRequirement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRequirement>>, {id: number;data: NonReadonly<Requirement>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRequirement(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRequirementMutationResult = NonNullable<Awaited<ReturnType<typeof updateRequirement>>>
    export type UpdateRequirementMutationBody = NonReadonly<Requirement>
    export type UpdateRequirementMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Requirement
 */
export const useUpdateRequirement = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequirement>>, TError,{id: number;data: NonReadonly<Requirement>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRequirement>>,
        TError,
        {id: number;data: NonReadonly<Requirement>},
        TContext
      > => {

      const mutationOptions = getUpdateRequirementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Requirement by its ID
 * @summary Delete a Requirement
 */
export const deleteRequirement = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteRequirementResponse200>(
      {url: `/api/Requirement/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRequirementMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRequirement>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRequirement>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteRequirement'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRequirement>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRequirement(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRequirementMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRequirement>>>
    
    export type DeleteRequirementMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Requirement
 */
export const useDeleteRequirement = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRequirement>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRequirement>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRequirementMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Room with optional search
 * @summary Get paginated list of Room
 */
export const getRoomPaginated = (
    params?: GetRoomPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedRoomResponse200>(
      {url: `/api/Room`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetRoomPaginatedQueryKey = (params?: GetRoomPaginatedParams,) => {
    return [`/api/Room`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRoomPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoomPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoomPaginated>>> = ({ signal }) => getRoomPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoomPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getRoomPaginated>>>
export type GetRoomPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetRoomPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRoomPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRoomPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Room
 */

export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoomPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Room by its ID
 * @summary Get a specific Room
 */
export const getRoomById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetRoomResponse200>(
      {url: `/api/Room/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetRoomByIdQueryKey = (id?: number,) => {
    return [`/api/Room/${id}`] as const;
    }

    
export const getGetRoomByIdQueryOptions = <TData = Awaited<ReturnType<typeof getRoomById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoomByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoomById>>> = ({ signal }) => getRoomById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoomByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRoomById>>>
export type GetRoomByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomById>>,
          TError,
          Awaited<ReturnType<typeof getRoomById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomById>>,
          TError,
          Awaited<ReturnType<typeof getRoomById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Room
 */

export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoomByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Room with the provided details
 * @summary Create a new Room
 */
export const createRoom = (
    room: Room,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateRoomResponse200>(
      {url: `/api/Room/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: room, signal
    },
      );
    }
  


export const getCreateRoomMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext> => {

const mutationKey = ['createRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoom>>, {data: Room}> = (props) => {
          const {data} = props ?? {};

          return  createRoom(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoomMutationResult = NonNullable<Awaited<ReturnType<typeof createRoom>>>
    export type CreateRoomMutationBody = Room
    export type CreateRoomMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Room
 */
export const useCreateRoom = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoom>>,
        TError,
        {data: Room},
        TContext
      > => {

      const mutationOptions = getCreateRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Room with the provided details
 * @summary Update a Room
 */
export const updateRoom = (
    id: number,
    room: Room,
 ) => {
      
      
      return fetchData<UpdateRoomResponse200>(
      {url: `/api/Room/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: room
    },
      );
    }
  


export const getUpdateRoomMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext> => {

const mutationKey = ['updateRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoom>>, {id: number;data: Room}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRoom(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoomMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoom>>>
    export type UpdateRoomMutationBody = Room
    export type UpdateRoomMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Room
 */
export const useUpdateRoom = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoom>>,
        TError,
        {id: number;data: Room},
        TContext
      > => {

      const mutationOptions = getUpdateRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Room by its ID
 * @summary Delete a Room
 */
export const deleteRoom = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteRoomResponse200>(
      {url: `/api/Room/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoomMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoom>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRoom(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoomMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoom>>>
    
    export type DeleteRoomMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Room
 */
export const useDeleteRoom = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoom>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of SchoolYear with optional search
 * @summary Get paginated list of SchoolYear
 */
export const getSchoolYearPaginated = (
    params?: GetSchoolYearPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedSchoolYearResponse200>(
      {url: `/api/SchoolYear`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetSchoolYearPaginatedQueryKey = (params?: GetSchoolYearPaginatedParams,) => {
    return [`/api/SchoolYear`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSchoolYearPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse>(params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchoolYearPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchoolYearPaginated>>> = ({ signal }) => getSchoolYearPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSchoolYearPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getSchoolYearPaginated>>>
export type GetSchoolYearPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse


export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse>(
 params: undefined |  GetSchoolYearPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearPaginated>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse>(
 params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearPaginated>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse>(
 params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of SchoolYear
 */

export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse>(
 params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSchoolYearPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new SchoolYear with the provided details
 * @summary Create a new SchoolYear
 */
export const createSchoolYear = (
    schoolYear: NonReadonly<SchoolYear>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateSchoolYearResponse200>(
      {url: `/api/SchoolYear`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: schoolYear, signal
    },
      );
    }
  


export const getCreateSchoolYearMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSchoolYear>>, TError,{data: NonReadonly<SchoolYear>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSchoolYear>>, TError,{data: NonReadonly<SchoolYear>}, TContext> => {

const mutationKey = ['createSchoolYear'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSchoolYear>>, {data: NonReadonly<SchoolYear>}> = (props) => {
          const {data} = props ?? {};

          return  createSchoolYear(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSchoolYearMutationResult = NonNullable<Awaited<ReturnType<typeof createSchoolYear>>>
    export type CreateSchoolYearMutationBody = NonReadonly<SchoolYear>
    export type CreateSchoolYearMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new SchoolYear
 */
export const useCreateSchoolYear = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSchoolYear>>, TError,{data: NonReadonly<SchoolYear>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSchoolYear>>,
        TError,
        {data: NonReadonly<SchoolYear>},
        TContext
      > => {

      const mutationOptions = getCreateSchoolYearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a SchoolYear by its ID
 * @summary Get a specific SchoolYear
 */
export const getSchoolYearById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetSchoolYearResponse200>(
      {url: `/api/SchoolYear/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSchoolYearByIdQueryKey = (id?: number,) => {
    return [`/api/SchoolYear/${id}`] as const;
    }

    
export const getGetSchoolYearByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchoolYearByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchoolYearById>>> = ({ signal }) => getSchoolYearById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSchoolYearByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSchoolYearById>>>
export type GetSchoolYearByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearById>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearById>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific SchoolYear
 */

export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSchoolYearByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing SchoolYear with the provided details
 * @summary Update a SchoolYear
 */
export const updateSchoolYear = (
    id: number,
    schoolYear: NonReadonly<SchoolYear>,
 ) => {
      
      
      return fetchData<UpdateSchoolYearResponse200>(
      {url: `/api/SchoolYear/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: schoolYear
    },
      );
    }
  


export const getUpdateSchoolYearMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchoolYear>>, TError,{id: number;data: NonReadonly<SchoolYear>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSchoolYear>>, TError,{id: number;data: NonReadonly<SchoolYear>}, TContext> => {

const mutationKey = ['updateSchoolYear'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSchoolYear>>, {id: number;data: NonReadonly<SchoolYear>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSchoolYear(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSchoolYearMutationResult = NonNullable<Awaited<ReturnType<typeof updateSchoolYear>>>
    export type UpdateSchoolYearMutationBody = NonReadonly<SchoolYear>
    export type UpdateSchoolYearMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a SchoolYear
 */
export const useUpdateSchoolYear = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchoolYear>>, TError,{id: number;data: NonReadonly<SchoolYear>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSchoolYear>>,
        TError,
        {id: number;data: NonReadonly<SchoolYear>},
        TContext
      > => {

      const mutationOptions = getUpdateSchoolYearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a SchoolYear by its ID
 * @summary Delete a SchoolYear
 */
export const deleteSchoolYear = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteSchoolYearResponse200>(
      {url: `/api/SchoolYear/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSchoolYearMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSchoolYear>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSchoolYear>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteSchoolYear'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSchoolYear>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSchoolYear(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSchoolYearMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSchoolYear>>>
    
    export type DeleteSchoolYearMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a SchoolYear
 */
export const useDeleteSchoolYear = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSchoolYear>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSchoolYear>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSchoolYearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Section with optional search
 * @summary Get paginated list of Section
 */
export const getSectionPaginated = (
    params?: GetSectionPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedSectionResponse200>(
      {url: `/api/Section`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetSectionPaginatedQueryKey = (params?: GetSectionPaginatedParams,) => {
    return [`/api/Section`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSectionPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getSectionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetSectionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSectionPaginated>>> = ({ signal }) => getSectionPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSectionPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSectionPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getSectionPaginated>>>
export type GetSectionPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetSectionPaginated<TData = Awaited<ReturnType<typeof getSectionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetSectionPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSectionPaginated>>,
          TError,
          Awaited<ReturnType<typeof getSectionPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSectionPaginated<TData = Awaited<ReturnType<typeof getSectionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetSectionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSectionPaginated>>,
          TError,
          Awaited<ReturnType<typeof getSectionPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSectionPaginated<TData = Awaited<ReturnType<typeof getSectionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetSectionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Section
 */

export function useGetSectionPaginated<TData = Awaited<ReturnType<typeof getSectionPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetSectionPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSectionPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Section with the provided details
 * @summary Create a new Section
 */
export const createSection = (
    section: NonReadonly<Section>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateSectionResponse200>(
      {url: `/api/Section`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: section, signal
    },
      );
    }
  


export const getCreateSectionMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSection>>, TError,{data: NonReadonly<Section>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSection>>, TError,{data: NonReadonly<Section>}, TContext> => {

const mutationKey = ['createSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSection>>, {data: NonReadonly<Section>}> = (props) => {
          const {data} = props ?? {};

          return  createSection(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSectionMutationResult = NonNullable<Awaited<ReturnType<typeof createSection>>>
    export type CreateSectionMutationBody = NonReadonly<Section>
    export type CreateSectionMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Section
 */
export const useCreateSection = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSection>>, TError,{data: NonReadonly<Section>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSection>>,
        TError,
        {data: NonReadonly<Section>},
        TContext
      > => {

      const mutationOptions = getCreateSectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Section by its ID
 * @summary Get a specific Section
 */
export const getSectionById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetSectionResponse200>(
      {url: `/api/Section/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSectionByIdQueryKey = (id?: number,) => {
    return [`/api/Section/${id}`] as const;
    }

    
export const getGetSectionByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSectionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSectionByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSectionById>>> = ({ signal }) => getSectionById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSectionById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSectionByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSectionById>>>
export type GetSectionByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetSectionById<TData = Awaited<ReturnType<typeof getSectionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSectionById>>,
          TError,
          Awaited<ReturnType<typeof getSectionById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSectionById<TData = Awaited<ReturnType<typeof getSectionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSectionById>>,
          TError,
          Awaited<ReturnType<typeof getSectionById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSectionById<TData = Awaited<ReturnType<typeof getSectionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Section
 */

export function useGetSectionById<TData = Awaited<ReturnType<typeof getSectionById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSectionById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSectionByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Section with the provided details
 * @summary Update a Section
 */
export const updateSection = (
    id: number,
    section: NonReadonly<Section>,
 ) => {
      
      
      return fetchData<UpdateSectionResponse200>(
      {url: `/api/Section/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: section
    },
      );
    }
  


export const getUpdateSectionMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSection>>, TError,{id: number;data: NonReadonly<Section>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSection>>, TError,{id: number;data: NonReadonly<Section>}, TContext> => {

const mutationKey = ['updateSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSection>>, {id: number;data: NonReadonly<Section>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSection(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSection>>>
    export type UpdateSectionMutationBody = NonReadonly<Section>
    export type UpdateSectionMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Section
 */
export const useUpdateSection = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSection>>, TError,{id: number;data: NonReadonly<Section>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSection>>,
        TError,
        {id: number;data: NonReadonly<Section>},
        TContext
      > => {

      const mutationOptions = getUpdateSectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Section by its ID
 * @summary Delete a Section
 */
export const deleteSection = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteSectionResponse200>(
      {url: `/api/Section/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSectionMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSection>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSection>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteSection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSection>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSection(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSection>>>
    
    export type DeleteSectionMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Section
 */
export const useDeleteSection = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSection>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSection>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSectionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Generate sections for a curriculum and year
 * @summary Generate sections for a curriculum and year
 */
export const generateSections = (
    generateSection: GenerateSection,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetSectionsResponse200>(
      {url: `/api/Section/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: generateSection, signal
    },
      );
    }
  


export const getGenerateSectionsMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateSections>>, TError,{data: GenerateSection}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateSections>>, TError,{data: GenerateSection}, TContext> => {

const mutationKey = ['generateSections'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateSections>>, {data: GenerateSection}> = (props) => {
          const {data} = props ?? {};

          return  generateSections(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateSectionsMutationResult = NonNullable<Awaited<ReturnType<typeof generateSections>>>
    export type GenerateSectionsMutationBody = GenerateSection
    export type GenerateSectionsMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Generate sections for a curriculum and year
 */
export const useGenerateSections = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateSections>>, TError,{data: GenerateSection}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateSections>>,
        TError,
        {data: GenerateSection},
        TContext
      > => {

      const mutationOptions = getGenerateSectionsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Section by its section code
 * @summary Delete a Section by its section code
 */
export const deleteSectionBySectionCode = (
    sectionCode: string,
 ) => {
      
      
      return fetchData<DeleteSectionResponse200>(
      {url: `/api/Section/code/${sectionCode}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSectionBySectionCodeMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSectionBySectionCode>>, TError,{sectionCode: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSectionBySectionCode>>, TError,{sectionCode: string}, TContext> => {

const mutationKey = ['deleteSectionBySectionCode'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSectionBySectionCode>>, {sectionCode: string}> = (props) => {
          const {sectionCode} = props ?? {};

          return  deleteSectionBySectionCode(sectionCode,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSectionBySectionCodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSectionBySectionCode>>>
    
    export type DeleteSectionBySectionCodeMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a Section by its section code
 */
export const useDeleteSectionBySectionCode = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSectionBySectionCode>>, TError,{sectionCode: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSectionBySectionCode>>,
        TError,
        {sectionCode: string},
        TContext
      > => {

      const mutationOptions = getDeleteSectionBySectionCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of User with optional search
 * @summary Get paginated list of User
 */
export const getUserPaginated = (
    params?: GetUserPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedUserResponse200>(
      {url: `/api/User`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetUserPaginatedQueryKey = (params?: GetUserPaginatedParams,) => {
    return [`/api/User`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getUserPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(params?: GetUserPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserPaginated>>> = ({ signal }) => getUserPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getUserPaginated>>>
export type GetUserPaginatedQueryError = UnauthenticatedResponse | ForbiddenResponse


export function useGetUserPaginated<TData = Awaited<ReturnType<typeof getUserPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params: undefined |  GetUserPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPaginated>>,
          TError,
          Awaited<ReturnType<typeof getUserPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPaginated<TData = Awaited<ReturnType<typeof getUserPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetUserPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPaginated>>,
          TError,
          Awaited<ReturnType<typeof getUserPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPaginated<TData = Awaited<ReturnType<typeof getUserPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetUserPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of User
 */

export function useGetUserPaginated<TData = Awaited<ReturnType<typeof getUserPaginated>>, TError = UnauthenticatedResponse | ForbiddenResponse>(
 params?: GetUserPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new User with the provided details
 * @summary Create a new User
 */
export const createUser = (
    user: NonReadonly<User>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateUserResponse200>(
      {url: `/api/User`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: user, signal
    },
      );
    }
  


export const getCreateUserMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: NonReadonly<User>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: NonReadonly<User>}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: NonReadonly<User>}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = NonReadonly<User>
    export type CreateUserMutationError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new User
 */
export const useCreateUser = <TError = UnauthenticatedResponse | ForbiddenResponse | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: NonReadonly<User>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: NonReadonly<User>},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a User by its ID
 * @summary Get a specific User
 */
export const getUserById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetUserResponse200>(
      {url: `/api/User/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserByIdQueryKey = (id?: number,) => {
    return [`/api/User/${id}`] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = UnauthenticatedResponse | ForbiddenResponse | null


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific User
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = UnauthenticatedResponse | ForbiddenResponse | null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing User with the provided details
 * @summary Update a User
 */
export const updateUser = (
    id: number,
    user: NonReadonly<User>,
 ) => {
      
      
      return fetchData<UpdateUserResponse200>(
      {url: `/api/User/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: user
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: NonReadonly<User>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: NonReadonly<User>}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {id: number;data: NonReadonly<User>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUser(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = NonReadonly<User>
    export type UpdateUserMutationError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a User
 */
export const useUpdateUser = <TError = UnauthenticatedResponse | ForbiddenResponse | null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: NonReadonly<User>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {id: number;data: NonReadonly<User>},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a User by its ID
 * @summary Delete a User
 */
export const deleteUser = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteUserResponse200>(
      {url: `/api/User/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse

    /**
 * @summary Delete a User
 */
export const useDeleteUser = <TError = UnauthenticatedResponse | ForbiddenResponse | null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
