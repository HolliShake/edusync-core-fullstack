/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * OpenEdusync API
 * API documentation for the OpenEdusy application
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AcademicProgram,
  Building,
  Campus,
  College,
  CreateAcademicProgramResponse200,
  CreateBuildingResponse200,
  CreateCampusResponse200,
  CreateCollegeResponse200,
  CreateProgramTypeResponse200,
  CreateRoomResponse200,
  DeleteAcademicProgramResponse200,
  DeleteBuildingResponse200,
  DeleteCampusResponse200,
  DeleteCollegeResponse200,
  DeleteProgramTypeResponse200,
  DeleteRoomResponse200,
  GetAcademicProgramPaginatedParams,
  GetAcademicProgramResponse200,
  GetBuildingPaginatedParams,
  GetBuildingResponse200,
  GetCampusPaginatedParams,
  GetCampusResponse200,
  GetCollegePaginatedParams,
  GetCollegeResponse200,
  GetProgramTypePaginatedParams,
  GetProgramTypeResponse200,
  GetRoomPaginatedParams,
  GetRoomResponse200,
  InternalServerErrorResponse,
  PaginatedAcademicProgramResponse200,
  PaginatedBuildingResponse200,
  PaginatedCampusResponse200,
  PaginatedCollegeResponse200,
  PaginatedProgramTypeResponse200,
  PaginatedRoomResponse200,
  ProgramType,
  Room,
  UpdateAcademicProgramResponse200,
  UpdateBuildingResponse200,
  UpdateCampusResponse200,
  UpdateCollegeResponse200,
  UpdateProgramTypeResponse200,
  UpdateRoomResponse200,
  ValidationErrorResponse
} from './models';

import { fetchData } from './axios';
/**
 * Retrieve a paginated list of AcademicProgram with optional search
 * @summary Get paginated list of AcademicProgram
 */
export const getAcademicProgramPaginated = (
    params?: GetAcademicProgramPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicProgramResponse200>(
      {url: `/api/AcademicProgram`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicProgramPaginatedQueryKey = (params?: GetAcademicProgramPaginatedParams,) => {
    return [`/api/AcademicProgram`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicProgramPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramPaginated>>> = ({ signal }) => getAcademicProgramPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramPaginated>>>
export type GetAcademicProgramPaginatedQueryError = unknown


export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params: undefined |  GetAcademicProgramPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicProgram
 */

export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a AcademicProgram by its ID
 * @summary Get a specific AcademicProgram
 */
export const getAcademicProgramById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicProgramByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicProgram/${id}`] as const;
    }

    
export const getGetAcademicProgramByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramById>>> = ({ signal }) => getAcademicProgramById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramById>>>
export type GetAcademicProgramByIdQueryError = null


export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicProgram
 */

export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicProgram with the provided details
 * @summary Create a new AcademicProgram
 */
export const createAcademicProgram = (
    academicProgram: AcademicProgram,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicProgram, signal
    },
      );
    }
  


export const getCreateAcademicProgramMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext> => {

const mutationKey = ['createAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicProgram>>, {data: AcademicProgram}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicProgram(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicProgram>>>
    export type CreateAcademicProgramMutationBody = AcademicProgram
    export type CreateAcademicProgramMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicProgram
 */
export const useCreateAcademicProgram = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicProgram>>,
        TError,
        {data: AcademicProgram},
        TContext
      > => {

      const mutationOptions = getCreateAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing AcademicProgram with the provided details
 * @summary Update a AcademicProgram
 */
export const updateAcademicProgram = (
    id: number,
    academicProgram: AcademicProgram,
 ) => {
      
      
      return fetchData<UpdateAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicProgram
    },
      );
    }
  


export const getUpdateAcademicProgramMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext> => {

const mutationKey = ['updateAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicProgram>>, {id: number;data: AcademicProgram}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicProgram(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicProgram>>>
    export type UpdateAcademicProgramMutationBody = AcademicProgram
    export type UpdateAcademicProgramMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicProgram
 */
export const useUpdateAcademicProgram = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicProgram>>,
        TError,
        {id: number;data: AcademicProgram},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicProgram by its ID
 * @summary Delete a AcademicProgram
 */
export const deleteAcademicProgram = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicProgramMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicProgram>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicProgram(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicProgram>>>
    
    export type DeleteAcademicProgramMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicProgram
 */
export const useDeleteAcademicProgram = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicProgram>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Building with optional search
 * @summary Get paginated list of Building
 */
export const getBuildingPaginated = (
    params?: GetBuildingPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedBuildingResponse200>(
      {url: `/api/Building`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetBuildingPaginatedQueryKey = (params?: GetBuildingPaginatedParams,) => {
    return [`/api/Building`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBuildingPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBuildingPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBuildingPaginated>>> = ({ signal }) => getBuildingPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBuildingPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getBuildingPaginated>>>
export type GetBuildingPaginatedQueryError = unknown


export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params: undefined |  GetBuildingPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingPaginated>>,
          TError,
          Awaited<ReturnType<typeof getBuildingPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingPaginated>>,
          TError,
          Awaited<ReturnType<typeof getBuildingPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Building
 */

export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBuildingPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Building by its ID
 * @summary Get a specific Building
 */
export const getBuildingById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetBuildingResponse200>(
      {url: `/api/Building/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBuildingByIdQueryKey = (id?: number,) => {
    return [`/api/Building/${id}`] as const;
    }

    
export const getGetBuildingByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBuildingByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBuildingById>>> = ({ signal }) => getBuildingById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBuildingByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBuildingById>>>
export type GetBuildingByIdQueryError = null


export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingById>>,
          TError,
          Awaited<ReturnType<typeof getBuildingById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingById>>,
          TError,
          Awaited<ReturnType<typeof getBuildingById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Building
 */

export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBuildingByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Building with the provided details
 * @summary Create a new Building
 */
export const createBuilding = (
    building: Building,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateBuildingResponse200>(
      {url: `/api/Building/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: building, signal
    },
      );
    }
  


export const getCreateBuildingMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext> => {

const mutationKey = ['createBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBuilding>>, {data: Building}> = (props) => {
          const {data} = props ?? {};

          return  createBuilding(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof createBuilding>>>
    export type CreateBuildingMutationBody = Building
    export type CreateBuildingMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Building
 */
export const useCreateBuilding = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBuilding>>,
        TError,
        {data: Building},
        TContext
      > => {

      const mutationOptions = getCreateBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Building with the provided details
 * @summary Update a Building
 */
export const updateBuilding = (
    id: number,
    building: Building,
 ) => {
      
      
      return fetchData<UpdateBuildingResponse200>(
      {url: `/api/Building/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: building
    },
      );
    }
  


export const getUpdateBuildingMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext> => {

const mutationKey = ['updateBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBuilding>>, {id: number;data: Building}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBuilding(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof updateBuilding>>>
    export type UpdateBuildingMutationBody = Building
    export type UpdateBuildingMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Building
 */
export const useUpdateBuilding = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBuilding>>,
        TError,
        {id: number;data: Building},
        TContext
      > => {

      const mutationOptions = getUpdateBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Building by its ID
 * @summary Delete a Building
 */
export const deleteBuilding = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteBuildingResponse200>(
      {url: `/api/Building/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBuildingMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBuilding>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBuilding(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBuilding>>>
    
    export type DeleteBuildingMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Building
 */
export const useDeleteBuilding = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBuilding>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Campus with optional search
 * @summary Get paginated list of Campus
 */
export const getCampusPaginated = (
    params?: GetCampusPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCampusResponse200>(
      {url: `/api/Campus`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCampusPaginatedQueryKey = (params?: GetCampusPaginatedParams,) => {
    return [`/api/Campus`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCampusPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCampusPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampusPaginated>>> = ({ signal }) => getCampusPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCampusPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCampusPaginated>>>
export type GetCampusPaginatedQueryError = unknown


export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params: undefined |  GetCampusPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCampusPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCampusPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Campus
 */

export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCampusPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Campus by its ID
 * @summary Get a specific Campus
 */
export const getCampusById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCampusResponse200>(
      {url: `/api/Campus/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCampusByIdQueryKey = (id?: number,) => {
    return [`/api/Campus/${id}`] as const;
    }

    
export const getGetCampusByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCampusByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampusById>>> = ({ signal }) => getCampusById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCampusByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCampusById>>>
export type GetCampusByIdQueryError = null


export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusById>>,
          TError,
          Awaited<ReturnType<typeof getCampusById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusById>>,
          TError,
          Awaited<ReturnType<typeof getCampusById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Campus
 */

export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCampusByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Campus with the provided details
 * @summary Create a new Campus
 */
export const createCampus = (
    campus: Campus,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCampusResponse200>(
      {url: `/api/Campus/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: campus, signal
    },
      );
    }
  


export const getCreateCampusMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext> => {

const mutationKey = ['createCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCampus>>, {data: Campus}> = (props) => {
          const {data} = props ?? {};

          return  createCampus(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCampusMutationResult = NonNullable<Awaited<ReturnType<typeof createCampus>>>
    export type CreateCampusMutationBody = Campus
    export type CreateCampusMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Campus
 */
export const useCreateCampus = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCampus>>,
        TError,
        {data: Campus},
        TContext
      > => {

      const mutationOptions = getCreateCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Campus with the provided details
 * @summary Update a Campus
 */
export const updateCampus = (
    id: number,
    campus: Campus,
 ) => {
      
      
      return fetchData<UpdateCampusResponse200>(
      {url: `/api/Campus/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: campus
    },
      );
    }
  


export const getUpdateCampusMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext> => {

const mutationKey = ['updateCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCampus>>, {id: number;data: Campus}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCampus(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCampusMutationResult = NonNullable<Awaited<ReturnType<typeof updateCampus>>>
    export type UpdateCampusMutationBody = Campus
    export type UpdateCampusMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Campus
 */
export const useUpdateCampus = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCampus>>,
        TError,
        {id: number;data: Campus},
        TContext
      > => {

      const mutationOptions = getUpdateCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Campus by its ID
 * @summary Delete a Campus
 */
export const deleteCampus = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCampusResponse200>(
      {url: `/api/Campus/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCampusMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCampus>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCampus(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCampusMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCampus>>>
    
    export type DeleteCampusMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Campus
 */
export const useDeleteCampus = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCampus>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of College with optional search
 * @summary Get paginated list of College
 */
export const getCollegePaginated = (
    params?: GetCollegePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCollegeResponse200>(
      {url: `/api/College`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCollegePaginatedQueryKey = (params?: GetCollegePaginatedParams,) => {
    return [`/api/College`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCollegePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollegePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollegePaginated>>> = ({ signal }) => getCollegePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCollegePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCollegePaginated>>>
export type GetCollegePaginatedQueryError = unknown


export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params: undefined |  GetCollegePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCollegePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCollegePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of College
 */

export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCollegePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a College by its ID
 * @summary Get a specific College
 */
export const getCollegeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCollegeResponse200>(
      {url: `/api/College/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCollegeByIdQueryKey = (id?: number,) => {
    return [`/api/College/${id}`] as const;
    }

    
export const getGetCollegeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollegeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollegeById>>> = ({ signal }) => getCollegeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCollegeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCollegeById>>>
export type GetCollegeByIdQueryError = null


export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegeById>>,
          TError,
          Awaited<ReturnType<typeof getCollegeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegeById>>,
          TError,
          Awaited<ReturnType<typeof getCollegeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific College
 */

export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCollegeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new College with the provided details
 * @summary Create a new College
 */
export const createCollege = (
    college: College,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCollegeResponse200>(
      {url: `/api/College/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: college, signal
    },
      );
    }
  


export const getCreateCollegeMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext> => {

const mutationKey = ['createCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollege>>, {data: College}> = (props) => {
          const {data} = props ?? {};

          return  createCollege(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof createCollege>>>
    export type CreateCollegeMutationBody = College
    export type CreateCollegeMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new College
 */
export const useCreateCollege = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCollege>>,
        TError,
        {data: College},
        TContext
      > => {

      const mutationOptions = getCreateCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing College with the provided details
 * @summary Update a College
 */
export const updateCollege = (
    id: number,
    college: College,
 ) => {
      
      
      return fetchData<UpdateCollegeResponse200>(
      {url: `/api/College/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: college
    },
      );
    }
  


export const getUpdateCollegeMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext> => {

const mutationKey = ['updateCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCollege>>, {id: number;data: College}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCollege(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof updateCollege>>>
    export type UpdateCollegeMutationBody = College
    export type UpdateCollegeMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a College
 */
export const useUpdateCollege = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCollege>>,
        TError,
        {id: number;data: College},
        TContext
      > => {

      const mutationOptions = getUpdateCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a College by its ID
 * @summary Delete a College
 */
export const deleteCollege = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCollegeResponse200>(
      {url: `/api/College/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCollegeMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCollege>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCollege(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCollege>>>
    
    export type DeleteCollegeMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a College
 */
export const useDeleteCollege = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCollege>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of ProgramType with optional search
 * @summary Get paginated list of ProgramType
 */
export const getProgramTypePaginated = (
    params?: GetProgramTypePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedProgramTypeResponse200>(
      {url: `/api/ProgramType`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetProgramTypePaginatedQueryKey = (params?: GetProgramTypePaginatedParams,) => {
    return [`/api/ProgramType`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProgramTypePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramTypePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramTypePaginated>>> = ({ signal }) => getProgramTypePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramTypePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramTypePaginated>>>
export type GetProgramTypePaginatedQueryError = unknown


export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params: undefined |  GetProgramTypePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of ProgramType
 */

export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramTypePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a ProgramType by its ID
 * @summary Get a specific ProgramType
 */
export const getProgramTypeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetProgramTypeResponse200>(
      {url: `/api/ProgramType/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProgramTypeByIdQueryKey = (id?: number,) => {
    return [`/api/ProgramType/${id}`] as const;
    }

    
export const getGetProgramTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramTypeById>>> = ({ signal }) => getProgramTypeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramTypeById>>>
export type GetProgramTypeByIdQueryError = null


export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypeById>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypeById>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific ProgramType
 */

export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new ProgramType with the provided details
 * @summary Create a new ProgramType
 */
export const createProgramType = (
    programType: ProgramType,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateProgramTypeResponse200>(
      {url: `/api/ProgramType/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: programType, signal
    },
      );
    }
  


export const getCreateProgramTypeMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext> => {

const mutationKey = ['createProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProgramType>>, {data: ProgramType}> = (props) => {
          const {data} = props ?? {};

          return  createProgramType(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createProgramType>>>
    export type CreateProgramTypeMutationBody = ProgramType
    export type CreateProgramTypeMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new ProgramType
 */
export const useCreateProgramType = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProgramType>>,
        TError,
        {data: ProgramType},
        TContext
      > => {

      const mutationOptions = getCreateProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing ProgramType with the provided details
 * @summary Update a ProgramType
 */
export const updateProgramType = (
    id: number,
    programType: ProgramType,
 ) => {
      
      
      return fetchData<UpdateProgramTypeResponse200>(
      {url: `/api/ProgramType/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: programType
    },
      );
    }
  


export const getUpdateProgramTypeMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext> => {

const mutationKey = ['updateProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProgramType>>, {id: number;data: ProgramType}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProgramType(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateProgramType>>>
    export type UpdateProgramTypeMutationBody = ProgramType
    export type UpdateProgramTypeMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a ProgramType
 */
export const useUpdateProgramType = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProgramType>>,
        TError,
        {id: number;data: ProgramType},
        TContext
      > => {

      const mutationOptions = getUpdateProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a ProgramType by its ID
 * @summary Delete a ProgramType
 */
export const deleteProgramType = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteProgramTypeResponse200>(
      {url: `/api/ProgramType/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProgramTypeMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProgramType>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProgramType(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProgramType>>>
    
    export type DeleteProgramTypeMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a ProgramType
 */
export const useDeleteProgramType = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProgramType>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Room with optional search
 * @summary Get paginated list of Room
 */
export const getRoomPaginated = (
    params?: GetRoomPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedRoomResponse200>(
      {url: `/api/Room`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetRoomPaginatedQueryKey = (params?: GetRoomPaginatedParams,) => {
    return [`/api/Room`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRoomPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoomPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoomPaginated>>> = ({ signal }) => getRoomPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoomPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getRoomPaginated>>>
export type GetRoomPaginatedQueryError = unknown


export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params: undefined |  GetRoomPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRoomPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRoomPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Room
 */

export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoomPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Room by its ID
 * @summary Get a specific Room
 */
export const getRoomById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetRoomResponse200>(
      {url: `/api/Room/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetRoomByIdQueryKey = (id?: number,) => {
    return [`/api/Room/${id}`] as const;
    }

    
export const getGetRoomByIdQueryOptions = <TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoomByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoomById>>> = ({ signal }) => getRoomById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoomByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRoomById>>>
export type GetRoomByIdQueryError = null


export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomById>>,
          TError,
          Awaited<ReturnType<typeof getRoomById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomById>>,
          TError,
          Awaited<ReturnType<typeof getRoomById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Room
 */

export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoomByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Room with the provided details
 * @summary Create a new Room
 */
export const createRoom = (
    room: Room,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateRoomResponse200>(
      {url: `/api/Room/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: room, signal
    },
      );
    }
  


export const getCreateRoomMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext> => {

const mutationKey = ['createRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoom>>, {data: Room}> = (props) => {
          const {data} = props ?? {};

          return  createRoom(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoomMutationResult = NonNullable<Awaited<ReturnType<typeof createRoom>>>
    export type CreateRoomMutationBody = Room
    export type CreateRoomMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Room
 */
export const useCreateRoom = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoom>>,
        TError,
        {data: Room},
        TContext
      > => {

      const mutationOptions = getCreateRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Room with the provided details
 * @summary Update a Room
 */
export const updateRoom = (
    id: number,
    room: Room,
 ) => {
      
      
      return fetchData<UpdateRoomResponse200>(
      {url: `/api/Room/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: room
    },
      );
    }
  


export const getUpdateRoomMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext> => {

const mutationKey = ['updateRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoom>>, {id: number;data: Room}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRoom(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoomMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoom>>>
    export type UpdateRoomMutationBody = Room
    export type UpdateRoomMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Room
 */
export const useUpdateRoom = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoom>>,
        TError,
        {id: number;data: Room},
        TContext
      > => {

      const mutationOptions = getUpdateRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Room by its ID
 * @summary Delete a Room
 */
export const deleteRoom = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteRoomResponse200>(
      {url: `/api/Room/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoomMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoom>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRoom(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoomMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoom>>>
    
    export type DeleteRoomMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Room
 */
export const useDeleteRoom = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoom>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
