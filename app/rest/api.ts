/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * OpenEdusync API
 * API documentation for the OpenEdusy application
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AcademicCalendar,
  AcademicProgram,
  AcademicTerm,
  Building,
  Campus,
  College,
  Course,
  CreateAcademicCalendarResponse200,
  CreateAcademicProgramResponse200,
  CreateAcademicTermResponse200,
  CreateBuildingResponse200,
  CreateCampusResponse200,
  CreateCollegeResponse200,
  CreateCourseResponse200,
  CreateCurriculumDetailResponse200,
  CreateCurriculumResponse200,
  CreateProgramTypeResponse200,
  CreateRoomResponse200,
  CreateSchoolYearResponse200,
  Curriculum,
  CurriculumDetail,
  DeleteAcademicCalendarResponse200,
  DeleteAcademicProgramResponse200,
  DeleteAcademicTermResponse200,
  DeleteBuildingResponse200,
  DeleteCampusResponse200,
  DeleteCollegeResponse200,
  DeleteCourseResponse200,
  DeleteCurriculumDetailResponse200,
  DeleteCurriculumResponse200,
  DeleteProgramTypeResponse200,
  DeleteRoomResponse200,
  DeleteSchoolYearResponse200,
  GetAcademicCalendarPaginatedParams,
  GetAcademicCalendarResponse200,
  GetAcademicProgramPaginatedParams,
  GetAcademicProgramResponse200,
  GetAcademicTermPaginatedParams,
  GetAcademicTermResponse200,
  GetBuildingPaginatedParams,
  GetBuildingResponse200,
  GetCampusPaginatedParams,
  GetCampusResponse200,
  GetCollegePaginatedParams,
  GetCollegeResponse200,
  GetCoursePaginatedParams,
  GetCourseResponse200,
  GetCurriculumDetailPaginatedParams,
  GetCurriculumDetailResponse200,
  GetCurriculumPaginatedParams,
  GetCurriculumResponse200,
  GetProgramTypePaginatedParams,
  GetProgramTypeResponse200,
  GetRoomPaginatedParams,
  GetRoomResponse200,
  GetSchoolYearPaginatedParams,
  GetSchoolYearResponse200,
  InternalServerErrorResponse,
  PaginatedAcademicCalendarResponse200,
  PaginatedAcademicProgramResponse200,
  PaginatedAcademicTermResponse200,
  PaginatedBuildingResponse200,
  PaginatedCampusResponse200,
  PaginatedCollegeResponse200,
  PaginatedCourseResponse200,
  PaginatedCurriculumDetailResponse200,
  PaginatedCurriculumResponse200,
  PaginatedProgramTypeResponse200,
  PaginatedRoomResponse200,
  PaginatedSchoolYearResponse200,
  ProgramType,
  Room,
  SchoolYear,
  UpdateAcademicCalendarResponse200,
  UpdateAcademicProgramResponse200,
  UpdateAcademicTermResponse200,
  UpdateBuildingResponse200,
  UpdateCampusResponse200,
  UpdateCollegeResponse200,
  UpdateCourseResponse200,
  UpdateCurriculumDetailResponse200,
  UpdateCurriculumResponse200,
  UpdateProgramTypeResponse200,
  UpdateRoomResponse200,
  UpdateSchoolYearResponse200,
  ValidationErrorResponse
} from './models';

import { fetchData } from './axios';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * Retrieve a paginated list of AcademicCalendar with optional search
 * @summary Get paginated list of AcademicCalendar
 */
export const getAcademicCalendarPaginated = (
    params?: GetAcademicCalendarPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicCalendarPaginatedQueryKey = (params?: GetAcademicCalendarPaginatedParams,) => {
    return [`/api/AcademicCalendar`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicCalendarPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = unknown>(params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicCalendarPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>> = ({ signal }) => getAcademicCalendarPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicCalendarPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>>
export type GetAcademicCalendarPaginatedQueryError = unknown


export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = unknown>(
 params: undefined |  GetAcademicCalendarPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = unknown>(
 params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = unknown>(
 params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicCalendar
 */

export function useGetAcademicCalendarPaginated<TData = Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError = unknown>(
 params?: GetAcademicCalendarPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicCalendarPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicCalendar with the provided details
 * @summary Create a new AcademicCalendar
 */
export const createAcademicCalendar = (
    academicCalendar: NonReadonly<AcademicCalendar>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicCalendar, signal
    },
      );
    }
  


export const getCreateAcademicCalendarMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicCalendar>>, TError,{data: NonReadonly<AcademicCalendar>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicCalendar>>, TError,{data: NonReadonly<AcademicCalendar>}, TContext> => {

const mutationKey = ['createAcademicCalendar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicCalendar>>, {data: NonReadonly<AcademicCalendar>}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicCalendar(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicCalendar>>>
    export type CreateAcademicCalendarMutationBody = NonReadonly<AcademicCalendar>
    export type CreateAcademicCalendarMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicCalendar
 */
export const useCreateAcademicCalendar = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicCalendar>>, TError,{data: NonReadonly<AcademicCalendar>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicCalendar>>,
        TError,
        {data: NonReadonly<AcademicCalendar>},
        TContext
      > => {

      const mutationOptions = getCreateAcademicCalendarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AcademicCalendar by its ID
 * @summary Get a specific AcademicCalendar
 */
export const getAcademicCalendarById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicCalendarByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicCalendar/${id}`] as const;
    }

    
export const getGetAcademicCalendarByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicCalendarByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicCalendarById>>> = ({ signal }) => getAcademicCalendarById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicCalendarByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicCalendarById>>>
export type GetAcademicCalendarByIdQueryError = null


export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicCalendarById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicCalendarById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicCalendar
 */

export function useGetAcademicCalendarById<TData = Awaited<ReturnType<typeof getAcademicCalendarById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicCalendarById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicCalendarByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AcademicCalendar with the provided details
 * @summary Update a AcademicCalendar
 */
export const updateAcademicCalendar = (
    id: number,
    academicCalendar: NonReadonly<AcademicCalendar>,
 ) => {
      
      
      return fetchData<UpdateAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicCalendar
    },
      );
    }
  


export const getUpdateAcademicCalendarMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicCalendar>>, TError,{id: number;data: NonReadonly<AcademicCalendar>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicCalendar>>, TError,{id: number;data: NonReadonly<AcademicCalendar>}, TContext> => {

const mutationKey = ['updateAcademicCalendar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicCalendar>>, {id: number;data: NonReadonly<AcademicCalendar>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicCalendar(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicCalendar>>>
    export type UpdateAcademicCalendarMutationBody = NonReadonly<AcademicCalendar>
    export type UpdateAcademicCalendarMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicCalendar
 */
export const useUpdateAcademicCalendar = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicCalendar>>, TError,{id: number;data: NonReadonly<AcademicCalendar>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicCalendar>>,
        TError,
        {id: number;data: NonReadonly<AcademicCalendar>},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicCalendarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicCalendar by its ID
 * @summary Delete a AcademicCalendar
 */
export const deleteAcademicCalendar = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicCalendarResponse200>(
      {url: `/api/AcademicCalendar/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicCalendarMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicCalendar>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicCalendar>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicCalendar'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicCalendar>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicCalendar(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicCalendarMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicCalendar>>>
    
    export type DeleteAcademicCalendarMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicCalendar
 */
export const useDeleteAcademicCalendar = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicCalendar>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicCalendar>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicCalendarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AcademicProgram with optional search
 * @summary Get paginated list of AcademicProgram
 */
export const getAcademicProgramPaginated = (
    params?: GetAcademicProgramPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicProgramResponse200>(
      {url: `/api/AcademicProgram`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicProgramPaginatedQueryKey = (params?: GetAcademicProgramPaginatedParams,) => {
    return [`/api/AcademicProgram`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicProgramPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramPaginated>>> = ({ signal }) => getAcademicProgramPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramPaginated>>>
export type GetAcademicProgramPaginatedQueryError = unknown


export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params: undefined |  GetAcademicProgramPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicProgram
 */

export function useGetAcademicProgramPaginated<TData = Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError = unknown>(
 params?: GetAcademicProgramPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a AcademicProgram by its ID
 * @summary Get a specific AcademicProgram
 */
export const getAcademicProgramById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicProgramByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicProgram/${id}`] as const;
    }

    
export const getGetAcademicProgramByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicProgramByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicProgramById>>> = ({ signal }) => getAcademicProgramById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicProgramByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicProgramById>>>
export type GetAcademicProgramByIdQueryError = null


export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicProgramById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicProgramById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicProgram
 */

export function useGetAcademicProgramById<TData = Awaited<ReturnType<typeof getAcademicProgramById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicProgramById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicProgramByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicProgram with the provided details
 * @summary Create a new AcademicProgram
 */
export const createAcademicProgram = (
    academicProgram: AcademicProgram,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicProgram, signal
    },
      );
    }
  


export const getCreateAcademicProgramMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext> => {

const mutationKey = ['createAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicProgram>>, {data: AcademicProgram}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicProgram(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicProgram>>>
    export type CreateAcademicProgramMutationBody = AcademicProgram
    export type CreateAcademicProgramMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicProgram
 */
export const useCreateAcademicProgram = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicProgram>>, TError,{data: AcademicProgram}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicProgram>>,
        TError,
        {data: AcademicProgram},
        TContext
      > => {

      const mutationOptions = getCreateAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing AcademicProgram with the provided details
 * @summary Update a AcademicProgram
 */
export const updateAcademicProgram = (
    id: number,
    academicProgram: AcademicProgram,
 ) => {
      
      
      return fetchData<UpdateAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicProgram
    },
      );
    }
  


export const getUpdateAcademicProgramMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext> => {

const mutationKey = ['updateAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicProgram>>, {id: number;data: AcademicProgram}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicProgram(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicProgram>>>
    export type UpdateAcademicProgramMutationBody = AcademicProgram
    export type UpdateAcademicProgramMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicProgram
 */
export const useUpdateAcademicProgram = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicProgram>>, TError,{id: number;data: AcademicProgram}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicProgram>>,
        TError,
        {id: number;data: AcademicProgram},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicProgram by its ID
 * @summary Delete a AcademicProgram
 */
export const deleteAcademicProgram = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicProgramResponse200>(
      {url: `/api/AcademicProgram/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicProgramMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicProgram'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicProgram>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicProgram(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicProgramMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicProgram>>>
    
    export type DeleteAcademicProgramMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicProgram
 */
export const useDeleteAcademicProgram = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicProgram>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicProgram>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of AcademicTerm with optional search
 * @summary Get paginated list of AcademicTerm
 */
export const getAcademicTermPaginated = (
    params?: GetAcademicTermPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedAcademicTermResponse200>(
      {url: `/api/AcademicTerm`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAcademicTermPaginatedQueryKey = (params?: GetAcademicTermPaginatedParams,) => {
    return [`/api/AcademicTerm`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAcademicTermPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = unknown>(params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicTermPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicTermPaginated>>> = ({ signal }) => getAcademicTermPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicTermPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicTermPaginated>>>
export type GetAcademicTermPaginatedQueryError = unknown


export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = unknown>(
 params: undefined |  GetAcademicTermPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = unknown>(
 params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermPaginated>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = unknown>(
 params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of AcademicTerm
 */

export function useGetAcademicTermPaginated<TData = Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError = unknown>(
 params?: GetAcademicTermPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicTermPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new AcademicTerm with the provided details
 * @summary Create a new AcademicTerm
 */
export const createAcademicTerm = (
    academicTerm: NonReadonly<AcademicTerm>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateAcademicTermResponse200>(
      {url: `/api/AcademicTerm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: academicTerm, signal
    },
      );
    }
  


export const getCreateAcademicTermMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicTerm>>, TError,{data: NonReadonly<AcademicTerm>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAcademicTerm>>, TError,{data: NonReadonly<AcademicTerm>}, TContext> => {

const mutationKey = ['createAcademicTerm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAcademicTerm>>, {data: NonReadonly<AcademicTerm>}> = (props) => {
          const {data} = props ?? {};

          return  createAcademicTerm(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAcademicTermMutationResult = NonNullable<Awaited<ReturnType<typeof createAcademicTerm>>>
    export type CreateAcademicTermMutationBody = NonReadonly<AcademicTerm>
    export type CreateAcademicTermMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new AcademicTerm
 */
export const useCreateAcademicTerm = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAcademicTerm>>, TError,{data: NonReadonly<AcademicTerm>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAcademicTerm>>,
        TError,
        {data: NonReadonly<AcademicTerm>},
        TContext
      > => {

      const mutationOptions = getCreateAcademicTermMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a AcademicTerm by its ID
 * @summary Get a specific AcademicTerm
 */
export const getAcademicTermById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetAcademicTermResponse200>(
      {url: `/api/AcademicTerm/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAcademicTermByIdQueryKey = (id?: number,) => {
    return [`/api/AcademicTerm/${id}`] as const;
    }

    
export const getGetAcademicTermByIdQueryOptions = <TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAcademicTermByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAcademicTermById>>> = ({ signal }) => getAcademicTermById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAcademicTermByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAcademicTermById>>>
export type GetAcademicTermByIdQueryError = null


export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAcademicTermById>>,
          TError,
          Awaited<ReturnType<typeof getAcademicTermById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific AcademicTerm
 */

export function useGetAcademicTermById<TData = Awaited<ReturnType<typeof getAcademicTermById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAcademicTermById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAcademicTermByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing AcademicTerm with the provided details
 * @summary Update a AcademicTerm
 */
export const updateAcademicTerm = (
    id: number,
    academicTerm: NonReadonly<AcademicTerm>,
 ) => {
      
      
      return fetchData<UpdateAcademicTermResponse200>(
      {url: `/api/AcademicTerm/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: academicTerm
    },
      );
    }
  


export const getUpdateAcademicTermMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicTerm>>, TError,{id: number;data: NonReadonly<AcademicTerm>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAcademicTerm>>, TError,{id: number;data: NonReadonly<AcademicTerm>}, TContext> => {

const mutationKey = ['updateAcademicTerm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAcademicTerm>>, {id: number;data: NonReadonly<AcademicTerm>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateAcademicTerm(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAcademicTermMutationResult = NonNullable<Awaited<ReturnType<typeof updateAcademicTerm>>>
    export type UpdateAcademicTermMutationBody = NonReadonly<AcademicTerm>
    export type UpdateAcademicTermMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a AcademicTerm
 */
export const useUpdateAcademicTerm = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAcademicTerm>>, TError,{id: number;data: NonReadonly<AcademicTerm>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAcademicTerm>>,
        TError,
        {id: number;data: NonReadonly<AcademicTerm>},
        TContext
      > => {

      const mutationOptions = getUpdateAcademicTermMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a AcademicTerm by its ID
 * @summary Delete a AcademicTerm
 */
export const deleteAcademicTerm = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteAcademicTermResponse200>(
      {url: `/api/AcademicTerm/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAcademicTermMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicTerm>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicTerm>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteAcademicTerm'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAcademicTerm>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteAcademicTerm(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAcademicTermMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAcademicTerm>>>
    
    export type DeleteAcademicTermMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a AcademicTerm
 */
export const useDeleteAcademicTerm = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAcademicTerm>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAcademicTerm>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteAcademicTermMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Building with optional search
 * @summary Get paginated list of Building
 */
export const getBuildingPaginated = (
    params?: GetBuildingPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedBuildingResponse200>(
      {url: `/api/Building`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetBuildingPaginatedQueryKey = (params?: GetBuildingPaginatedParams,) => {
    return [`/api/Building`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBuildingPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBuildingPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBuildingPaginated>>> = ({ signal }) => getBuildingPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBuildingPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getBuildingPaginated>>>
export type GetBuildingPaginatedQueryError = unknown


export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params: undefined |  GetBuildingPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingPaginated>>,
          TError,
          Awaited<ReturnType<typeof getBuildingPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingPaginated>>,
          TError,
          Awaited<ReturnType<typeof getBuildingPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Building
 */

export function useGetBuildingPaginated<TData = Awaited<ReturnType<typeof getBuildingPaginated>>, TError = unknown>(
 params?: GetBuildingPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBuildingPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Building by its ID
 * @summary Get a specific Building
 */
export const getBuildingById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetBuildingResponse200>(
      {url: `/api/Building/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetBuildingByIdQueryKey = (id?: number,) => {
    return [`/api/Building/${id}`] as const;
    }

    
export const getGetBuildingByIdQueryOptions = <TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBuildingByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBuildingById>>> = ({ signal }) => getBuildingById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBuildingByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBuildingById>>>
export type GetBuildingByIdQueryError = null


export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingById>>,
          TError,
          Awaited<ReturnType<typeof getBuildingById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBuildingById>>,
          TError,
          Awaited<ReturnType<typeof getBuildingById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Building
 */

export function useGetBuildingById<TData = Awaited<ReturnType<typeof getBuildingById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBuildingById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBuildingByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Building with the provided details
 * @summary Create a new Building
 */
export const createBuilding = (
    building: Building,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateBuildingResponse200>(
      {url: `/api/Building/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: building, signal
    },
      );
    }
  


export const getCreateBuildingMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext> => {

const mutationKey = ['createBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBuilding>>, {data: Building}> = (props) => {
          const {data} = props ?? {};

          return  createBuilding(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof createBuilding>>>
    export type CreateBuildingMutationBody = Building
    export type CreateBuildingMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Building
 */
export const useCreateBuilding = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBuilding>>, TError,{data: Building}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBuilding>>,
        TError,
        {data: Building},
        TContext
      > => {

      const mutationOptions = getCreateBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Building with the provided details
 * @summary Update a Building
 */
export const updateBuilding = (
    id: number,
    building: Building,
 ) => {
      
      
      return fetchData<UpdateBuildingResponse200>(
      {url: `/api/Building/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: building
    },
      );
    }
  


export const getUpdateBuildingMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext> => {

const mutationKey = ['updateBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBuilding>>, {id: number;data: Building}> = (props) => {
          const {id,data} = props ?? {};

          return  updateBuilding(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof updateBuilding>>>
    export type UpdateBuildingMutationBody = Building
    export type UpdateBuildingMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Building
 */
export const useUpdateBuilding = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBuilding>>, TError,{id: number;data: Building}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBuilding>>,
        TError,
        {id: number;data: Building},
        TContext
      > => {

      const mutationOptions = getUpdateBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Building by its ID
 * @summary Delete a Building
 */
export const deleteBuilding = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteBuildingResponse200>(
      {url: `/api/Building/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBuildingMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteBuilding'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBuilding>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteBuilding(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBuildingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBuilding>>>
    
    export type DeleteBuildingMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Building
 */
export const useDeleteBuilding = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBuilding>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBuilding>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteBuildingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Campus with optional search
 * @summary Get paginated list of Campus
 */
export const getCampusPaginated = (
    params?: GetCampusPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCampusResponse200>(
      {url: `/api/Campus`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCampusPaginatedQueryKey = (params?: GetCampusPaginatedParams,) => {
    return [`/api/Campus`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCampusPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCampusPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampusPaginated>>> = ({ signal }) => getCampusPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCampusPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCampusPaginated>>>
export type GetCampusPaginatedQueryError = unknown


export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params: undefined |  GetCampusPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCampusPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCampusPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Campus
 */

export function useGetCampusPaginated<TData = Awaited<ReturnType<typeof getCampusPaginated>>, TError = unknown>(
 params?: GetCampusPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCampusPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Campus by its ID
 * @summary Get a specific Campus
 */
export const getCampusById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCampusResponse200>(
      {url: `/api/Campus/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCampusByIdQueryKey = (id?: number,) => {
    return [`/api/Campus/${id}`] as const;
    }

    
export const getGetCampusByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCampusByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampusById>>> = ({ signal }) => getCampusById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCampusByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCampusById>>>
export type GetCampusByIdQueryError = null


export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusById>>,
          TError,
          Awaited<ReturnType<typeof getCampusById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCampusById>>,
          TError,
          Awaited<ReturnType<typeof getCampusById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Campus
 */

export function useGetCampusById<TData = Awaited<ReturnType<typeof getCampusById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampusById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCampusByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Campus with the provided details
 * @summary Create a new Campus
 */
export const createCampus = (
    campus: Campus,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCampusResponse200>(
      {url: `/api/Campus/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: campus, signal
    },
      );
    }
  


export const getCreateCampusMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext> => {

const mutationKey = ['createCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCampus>>, {data: Campus}> = (props) => {
          const {data} = props ?? {};

          return  createCampus(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCampusMutationResult = NonNullable<Awaited<ReturnType<typeof createCampus>>>
    export type CreateCampusMutationBody = Campus
    export type CreateCampusMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Campus
 */
export const useCreateCampus = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCampus>>, TError,{data: Campus}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCampus>>,
        TError,
        {data: Campus},
        TContext
      > => {

      const mutationOptions = getCreateCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Campus with the provided details
 * @summary Update a Campus
 */
export const updateCampus = (
    id: number,
    campus: Campus,
 ) => {
      
      
      return fetchData<UpdateCampusResponse200>(
      {url: `/api/Campus/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: campus
    },
      );
    }
  


export const getUpdateCampusMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext> => {

const mutationKey = ['updateCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCampus>>, {id: number;data: Campus}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCampus(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCampusMutationResult = NonNullable<Awaited<ReturnType<typeof updateCampus>>>
    export type UpdateCampusMutationBody = Campus
    export type UpdateCampusMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Campus
 */
export const useUpdateCampus = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCampus>>, TError,{id: number;data: Campus}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCampus>>,
        TError,
        {id: number;data: Campus},
        TContext
      > => {

      const mutationOptions = getUpdateCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Campus by its ID
 * @summary Delete a Campus
 */
export const deleteCampus = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCampusResponse200>(
      {url: `/api/Campus/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCampusMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCampus'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCampus>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCampus(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCampusMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCampus>>>
    
    export type DeleteCampusMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Campus
 */
export const useDeleteCampus = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCampus>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCampus>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCampusMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of College with optional search
 * @summary Get paginated list of College
 */
export const getCollegePaginated = (
    params?: GetCollegePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCollegeResponse200>(
      {url: `/api/College`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCollegePaginatedQueryKey = (params?: GetCollegePaginatedParams,) => {
    return [`/api/College`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCollegePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollegePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollegePaginated>>> = ({ signal }) => getCollegePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCollegePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCollegePaginated>>>
export type GetCollegePaginatedQueryError = unknown


export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params: undefined |  GetCollegePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCollegePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCollegePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of College
 */

export function useGetCollegePaginated<TData = Awaited<ReturnType<typeof getCollegePaginated>>, TError = unknown>(
 params?: GetCollegePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCollegePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a College by its ID
 * @summary Get a specific College
 */
export const getCollegeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCollegeResponse200>(
      {url: `/api/College/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCollegeByIdQueryKey = (id?: number,) => {
    return [`/api/College/${id}`] as const;
    }

    
export const getGetCollegeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollegeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollegeById>>> = ({ signal }) => getCollegeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCollegeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCollegeById>>>
export type GetCollegeByIdQueryError = null


export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegeById>>,
          TError,
          Awaited<ReturnType<typeof getCollegeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCollegeById>>,
          TError,
          Awaited<ReturnType<typeof getCollegeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific College
 */

export function useGetCollegeById<TData = Awaited<ReturnType<typeof getCollegeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCollegeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCollegeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new College with the provided details
 * @summary Create a new College
 */
export const createCollege = (
    college: College,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCollegeResponse200>(
      {url: `/api/College/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: college, signal
    },
      );
    }
  


export const getCreateCollegeMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext> => {

const mutationKey = ['createCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollege>>, {data: College}> = (props) => {
          const {data} = props ?? {};

          return  createCollege(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof createCollege>>>
    export type CreateCollegeMutationBody = College
    export type CreateCollegeMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new College
 */
export const useCreateCollege = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollege>>, TError,{data: College}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCollege>>,
        TError,
        {data: College},
        TContext
      > => {

      const mutationOptions = getCreateCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing College with the provided details
 * @summary Update a College
 */
export const updateCollege = (
    id: number,
    college: College,
 ) => {
      
      
      return fetchData<UpdateCollegeResponse200>(
      {url: `/api/College/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: college
    },
      );
    }
  


export const getUpdateCollegeMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext> => {

const mutationKey = ['updateCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCollege>>, {id: number;data: College}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCollege(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof updateCollege>>>
    export type UpdateCollegeMutationBody = College
    export type UpdateCollegeMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a College
 */
export const useUpdateCollege = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollege>>, TError,{id: number;data: College}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCollege>>,
        TError,
        {id: number;data: College},
        TContext
      > => {

      const mutationOptions = getUpdateCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a College by its ID
 * @summary Delete a College
 */
export const deleteCollege = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCollegeResponse200>(
      {url: `/api/College/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCollegeMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCollege'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCollege>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCollege(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCollegeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCollege>>>
    
    export type DeleteCollegeMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a College
 */
export const useDeleteCollege = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollege>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCollege>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCollegeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Course with optional search
 * @summary Get paginated list of Course
 */
export const getCoursePaginated = (
    params?: GetCoursePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCourseResponse200>(
      {url: `/api/Course`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCoursePaginatedQueryKey = (params?: GetCoursePaginatedParams,) => {
    return [`/api/Course`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCoursePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = unknown>(params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCoursePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCoursePaginated>>> = ({ signal }) => getCoursePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCoursePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCoursePaginated>>>
export type GetCoursePaginatedQueryError = unknown


export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = unknown>(
 params: undefined |  GetCoursePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoursePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCoursePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = unknown>(
 params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCoursePaginated>>,
          TError,
          Awaited<ReturnType<typeof getCoursePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = unknown>(
 params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Course
 */

export function useGetCoursePaginated<TData = Awaited<ReturnType<typeof getCoursePaginated>>, TError = unknown>(
 params?: GetCoursePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCoursePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCoursePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Course with the provided details
 * @summary Create a new Course
 */
export const createCourse = (
    course: Course,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCourseResponse200>(
      {url: `/api/Course`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: course, signal
    },
      );
    }
  


export const getCreateCourseMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCourse>>, TError,{data: Course}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCourse>>, TError,{data: Course}, TContext> => {

const mutationKey = ['createCourse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCourse>>, {data: Course}> = (props) => {
          const {data} = props ?? {};

          return  createCourse(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCourseMutationResult = NonNullable<Awaited<ReturnType<typeof createCourse>>>
    export type CreateCourseMutationBody = Course
    export type CreateCourseMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Course
 */
export const useCreateCourse = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCourse>>, TError,{data: Course}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCourse>>,
        TError,
        {data: Course},
        TContext
      > => {

      const mutationOptions = getCreateCourseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Course by its ID
 * @summary Get a specific Course
 */
export const getCourseById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCourseResponse200>(
      {url: `/api/Course/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCourseByIdQueryKey = (id?: number,) => {
    return [`/api/Course/${id}`] as const;
    }

    
export const getGetCourseByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCourseById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCourseByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCourseById>>> = ({ signal }) => getCourseById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCourseByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCourseById>>>
export type GetCourseByIdQueryError = null


export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseById>>,
          TError,
          Awaited<ReturnType<typeof getCourseById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCourseById>>,
          TError,
          Awaited<ReturnType<typeof getCourseById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Course
 */

export function useGetCourseById<TData = Awaited<ReturnType<typeof getCourseById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCourseById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCourseByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Course with the provided details
 * @summary Update a Course
 */
export const updateCourse = (
    id: number,
    course: Course,
 ) => {
      
      
      return fetchData<UpdateCourseResponse200>(
      {url: `/api/Course/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: course
    },
      );
    }
  


export const getUpdateCourseMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCourse>>, TError,{id: number;data: Course}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCourse>>, TError,{id: number;data: Course}, TContext> => {

const mutationKey = ['updateCourse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCourse>>, {id: number;data: Course}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCourse(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCourseMutationResult = NonNullable<Awaited<ReturnType<typeof updateCourse>>>
    export type UpdateCourseMutationBody = Course
    export type UpdateCourseMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Course
 */
export const useUpdateCourse = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCourse>>, TError,{id: number;data: Course}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCourse>>,
        TError,
        {id: number;data: Course},
        TContext
      > => {

      const mutationOptions = getUpdateCourseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Course by its ID
 * @summary Delete a Course
 */
export const deleteCourse = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCourseResponse200>(
      {url: `/api/Course/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCourseMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCourse>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCourse>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCourse'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCourse>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCourse(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCourseMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCourse>>>
    
    export type DeleteCourseMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Course
 */
export const useDeleteCourse = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCourse>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCourse>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCourseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Curriculum with optional search
 * @summary Get paginated list of Curriculum
 */
export const getCurriculumPaginated = (
    params?: GetCurriculumPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCurriculumResponse200>(
      {url: `/api/Curriculum`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCurriculumPaginatedQueryKey = (params?: GetCurriculumPaginatedParams,) => {
    return [`/api/Curriculum`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCurriculumPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = unknown>(params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumPaginated>>> = ({ signal }) => getCurriculumPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumPaginated>>>
export type GetCurriculumPaginatedQueryError = unknown


export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = unknown>(
 params: undefined |  GetCurriculumPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = unknown>(
 params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = unknown>(
 params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Curriculum
 */

export function useGetCurriculumPaginated<TData = Awaited<ReturnType<typeof getCurriculumPaginated>>, TError = unknown>(
 params?: GetCurriculumPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Curriculum with the provided details
 * @summary Create a new Curriculum
 */
export const createCurriculum = (
    curriculum: Curriculum,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCurriculumResponse200>(
      {url: `/api/Curriculum`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: curriculum, signal
    },
      );
    }
  


export const getCreateCurriculumMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculum>>, TError,{data: Curriculum}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCurriculum>>, TError,{data: Curriculum}, TContext> => {

const mutationKey = ['createCurriculum'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCurriculum>>, {data: Curriculum}> = (props) => {
          const {data} = props ?? {};

          return  createCurriculum(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCurriculumMutationResult = NonNullable<Awaited<ReturnType<typeof createCurriculum>>>
    export type CreateCurriculumMutationBody = Curriculum
    export type CreateCurriculumMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Curriculum
 */
export const useCreateCurriculum = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculum>>, TError,{data: Curriculum}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCurriculum>>,
        TError,
        {data: Curriculum},
        TContext
      > => {

      const mutationOptions = getCreateCurriculumMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a Curriculum by its ID
 * @summary Get a specific Curriculum
 */
export const getCurriculumById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCurriculumResponse200>(
      {url: `/api/Curriculum/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurriculumByIdQueryKey = (id?: number,) => {
    return [`/api/Curriculum/${id}`] as const;
    }

    
export const getGetCurriculumByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumById>>> = ({ signal }) => getCurriculumById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumById>>>
export type GetCurriculumByIdQueryError = null


export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Curriculum
 */

export function useGetCurriculumById<TData = Awaited<ReturnType<typeof getCurriculumById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing Curriculum with the provided details
 * @summary Update a Curriculum
 */
export const updateCurriculum = (
    id: number,
    curriculum: Curriculum,
 ) => {
      
      
      return fetchData<UpdateCurriculumResponse200>(
      {url: `/api/Curriculum/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: curriculum
    },
      );
    }
  


export const getUpdateCurriculumMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculum>>, TError,{id: number;data: Curriculum}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurriculum>>, TError,{id: number;data: Curriculum}, TContext> => {

const mutationKey = ['updateCurriculum'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurriculum>>, {id: number;data: Curriculum}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurriculum(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurriculumMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurriculum>>>
    export type UpdateCurriculumMutationBody = Curriculum
    export type UpdateCurriculumMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Curriculum
 */
export const useUpdateCurriculum = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculum>>, TError,{id: number;data: Curriculum}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurriculum>>,
        TError,
        {id: number;data: Curriculum},
        TContext
      > => {

      const mutationOptions = getUpdateCurriculumMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Curriculum by its ID
 * @summary Delete a Curriculum
 */
export const deleteCurriculum = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCurriculumResponse200>(
      {url: `/api/Curriculum/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurriculumMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculum>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculum>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCurriculum'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurriculum>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurriculum(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCurriculumMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurriculum>>>
    
    export type DeleteCurriculumMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Curriculum
 */
export const useDeleteCurriculum = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculum>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCurriculum>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurriculumMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of CurriculumDetail with optional search
 * @summary Get paginated list of CurriculumDetail
 */
export const getCurriculumDetailPaginated = (
    params?: GetCurriculumDetailPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetCurriculumDetailPaginatedQueryKey = (params?: GetCurriculumDetailPaginatedParams,) => {
    return [`/api/CurriculumDetail`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCurriculumDetailPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = unknown>(params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumDetailPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>> = ({ signal }) => getCurriculumDetailPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumDetailPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>>
export type GetCurriculumDetailPaginatedQueryError = unknown


export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = unknown>(
 params: undefined |  GetCurriculumDetailPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = unknown>(
 params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = unknown>(
 params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of CurriculumDetail
 */

export function useGetCurriculumDetailPaginated<TData = Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError = unknown>(
 params?: GetCurriculumDetailPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumDetailPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new CurriculumDetail with the provided details
 * @summary Create a new CurriculumDetail
 */
export const createCurriculumDetail = (
    curriculumDetail: NonReadonly<CurriculumDetail>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: curriculumDetail, signal
    },
      );
    }
  


export const getCreateCurriculumDetailMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculumDetail>>, TError,{data: NonReadonly<CurriculumDetail>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCurriculumDetail>>, TError,{data: NonReadonly<CurriculumDetail>}, TContext> => {

const mutationKey = ['createCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCurriculumDetail>>, {data: NonReadonly<CurriculumDetail>}> = (props) => {
          const {data} = props ?? {};

          return  createCurriculumDetail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof createCurriculumDetail>>>
    export type CreateCurriculumDetailMutationBody = NonReadonly<CurriculumDetail>
    export type CreateCurriculumDetailMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new CurriculumDetail
 */
export const useCreateCurriculumDetail = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCurriculumDetail>>, TError,{data: NonReadonly<CurriculumDetail>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCurriculumDetail>>,
        TError,
        {data: NonReadonly<CurriculumDetail>},
        TContext
      > => {

      const mutationOptions = getCreateCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a CurriculumDetail by its ID
 * @summary Get a specific CurriculumDetail
 */
export const getCurriculumDetailById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurriculumDetailByIdQueryKey = (id?: number,) => {
    return [`/api/CurriculumDetail/${id}`] as const;
    }

    
export const getGetCurriculumDetailByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurriculumDetailByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurriculumDetailById>>> = ({ signal }) => getCurriculumDetailById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurriculumDetailByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCurriculumDetailById>>>
export type GetCurriculumDetailByIdQueryError = null


export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurriculumDetailById>>,
          TError,
          Awaited<ReturnType<typeof getCurriculumDetailById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific CurriculumDetail
 */

export function useGetCurriculumDetailById<TData = Awaited<ReturnType<typeof getCurriculumDetailById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurriculumDetailById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurriculumDetailByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing CurriculumDetail with the provided details
 * @summary Update a CurriculumDetail
 */
export const updateCurriculumDetail = (
    id: number,
    curriculumDetail: NonReadonly<CurriculumDetail>,
 ) => {
      
      
      return fetchData<UpdateCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: curriculumDetail
    },
      );
    }
  


export const getUpdateCurriculumDetailMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculumDetail>>, TError,{id: number;data: NonReadonly<CurriculumDetail>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurriculumDetail>>, TError,{id: number;data: NonReadonly<CurriculumDetail>}, TContext> => {

const mutationKey = ['updateCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurriculumDetail>>, {id: number;data: NonReadonly<CurriculumDetail>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCurriculumDetail(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurriculumDetail>>>
    export type UpdateCurriculumDetailMutationBody = NonReadonly<CurriculumDetail>
    export type UpdateCurriculumDetailMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a CurriculumDetail
 */
export const useUpdateCurriculumDetail = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurriculumDetail>>, TError,{id: number;data: NonReadonly<CurriculumDetail>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurriculumDetail>>,
        TError,
        {id: number;data: NonReadonly<CurriculumDetail>},
        TContext
      > => {

      const mutationOptions = getUpdateCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a CurriculumDetail by its ID
 * @summary Delete a CurriculumDetail
 */
export const deleteCurriculumDetail = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteCurriculumDetailResponse200>(
      {url: `/api/CurriculumDetail/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurriculumDetailMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculumDetail>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculumDetail>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCurriculumDetail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurriculumDetail>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCurriculumDetail(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCurriculumDetailMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurriculumDetail>>>
    
    export type DeleteCurriculumDetailMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a CurriculumDetail
 */
export const useDeleteCurriculumDetail = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurriculumDetail>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCurriculumDetail>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCurriculumDetailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of ProgramType with optional search
 * @summary Get paginated list of ProgramType
 */
export const getProgramTypePaginated = (
    params?: GetProgramTypePaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedProgramTypeResponse200>(
      {url: `/api/ProgramType`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetProgramTypePaginatedQueryKey = (params?: GetProgramTypePaginatedParams,) => {
    return [`/api/ProgramType`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProgramTypePaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramTypePaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramTypePaginated>>> = ({ signal }) => getProgramTypePaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramTypePaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramTypePaginated>>>
export type GetProgramTypePaginatedQueryError = unknown


export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params: undefined |  GetProgramTypePaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypePaginated>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypePaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of ProgramType
 */

export function useGetProgramTypePaginated<TData = Awaited<ReturnType<typeof getProgramTypePaginated>>, TError = unknown>(
 params?: GetProgramTypePaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypePaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramTypePaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a ProgramType by its ID
 * @summary Get a specific ProgramType
 */
export const getProgramTypeById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetProgramTypeResponse200>(
      {url: `/api/ProgramType/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetProgramTypeByIdQueryKey = (id?: number,) => {
    return [`/api/ProgramType/${id}`] as const;
    }

    
export const getGetProgramTypeByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramTypeByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramTypeById>>> = ({ signal }) => getProgramTypeById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramTypeByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramTypeById>>>
export type GetProgramTypeByIdQueryError = null


export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypeById>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramTypeById>>,
          TError,
          Awaited<ReturnType<typeof getProgramTypeById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific ProgramType
 */

export function useGetProgramTypeById<TData = Awaited<ReturnType<typeof getProgramTypeById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramTypeById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramTypeByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new ProgramType with the provided details
 * @summary Create a new ProgramType
 */
export const createProgramType = (
    programType: ProgramType,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateProgramTypeResponse200>(
      {url: `/api/ProgramType/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: programType, signal
    },
      );
    }
  


export const getCreateProgramTypeMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext> => {

const mutationKey = ['createProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProgramType>>, {data: ProgramType}> = (props) => {
          const {data} = props ?? {};

          return  createProgramType(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createProgramType>>>
    export type CreateProgramTypeMutationBody = ProgramType
    export type CreateProgramTypeMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new ProgramType
 */
export const useCreateProgramType = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgramType>>, TError,{data: ProgramType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProgramType>>,
        TError,
        {data: ProgramType},
        TContext
      > => {

      const mutationOptions = getCreateProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing ProgramType with the provided details
 * @summary Update a ProgramType
 */
export const updateProgramType = (
    id: number,
    programType: ProgramType,
 ) => {
      
      
      return fetchData<UpdateProgramTypeResponse200>(
      {url: `/api/ProgramType/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: programType
    },
      );
    }
  


export const getUpdateProgramTypeMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext> => {

const mutationKey = ['updateProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProgramType>>, {id: number;data: ProgramType}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProgramType(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateProgramType>>>
    export type UpdateProgramTypeMutationBody = ProgramType
    export type UpdateProgramTypeMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a ProgramType
 */
export const useUpdateProgramType = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramType>>, TError,{id: number;data: ProgramType}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProgramType>>,
        TError,
        {id: number;data: ProgramType},
        TContext
      > => {

      const mutationOptions = getUpdateProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a ProgramType by its ID
 * @summary Delete a ProgramType
 */
export const deleteProgramType = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteProgramTypeResponse200>(
      {url: `/api/ProgramType/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProgramTypeMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteProgramType'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProgramType>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteProgramType(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProgramTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProgramType>>>
    
    export type DeleteProgramTypeMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a ProgramType
 */
export const useDeleteProgramType = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramType>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProgramType>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteProgramTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of Room with optional search
 * @summary Get paginated list of Room
 */
export const getRoomPaginated = (
    params?: GetRoomPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedRoomResponse200>(
      {url: `/api/Room`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetRoomPaginatedQueryKey = (params?: GetRoomPaginatedParams,) => {
    return [`/api/Room`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRoomPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoomPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoomPaginated>>> = ({ signal }) => getRoomPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoomPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getRoomPaginated>>>
export type GetRoomPaginatedQueryError = unknown


export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params: undefined |  GetRoomPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRoomPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomPaginated>>,
          TError,
          Awaited<ReturnType<typeof getRoomPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of Room
 */

export function useGetRoomPaginated<TData = Awaited<ReturnType<typeof getRoomPaginated>>, TError = unknown>(
 params?: GetRoomPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoomPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a Room by its ID
 * @summary Get a specific Room
 */
export const getRoomById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetRoomResponse200>(
      {url: `/api/Room/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetRoomByIdQueryKey = (id?: number,) => {
    return [`/api/Room/${id}`] as const;
    }

    
export const getGetRoomByIdQueryOptions = <TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoomByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoomById>>> = ({ signal }) => getRoomById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoomByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRoomById>>>
export type GetRoomByIdQueryError = null


export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomById>>,
          TError,
          Awaited<ReturnType<typeof getRoomById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoomById>>,
          TError,
          Awaited<ReturnType<typeof getRoomById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific Room
 */

export function useGetRoomById<TData = Awaited<ReturnType<typeof getRoomById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoomById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoomByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new Room with the provided details
 * @summary Create a new Room
 */
export const createRoom = (
    room: Room,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateRoomResponse200>(
      {url: `/api/Room/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: room, signal
    },
      );
    }
  


export const getCreateRoomMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext> => {

const mutationKey = ['createRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoom>>, {data: Room}> = (props) => {
          const {data} = props ?? {};

          return  createRoom(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoomMutationResult = NonNullable<Awaited<ReturnType<typeof createRoom>>>
    export type CreateRoomMutationBody = Room
    export type CreateRoomMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new Room
 */
export const useCreateRoom = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoom>>, TError,{data: Room}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoom>>,
        TError,
        {data: Room},
        TContext
      > => {

      const mutationOptions = getCreateRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update an existing Room with the provided details
 * @summary Update a Room
 */
export const updateRoom = (
    id: number,
    room: Room,
 ) => {
      
      
      return fetchData<UpdateRoomResponse200>(
      {url: `/api/Room/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: room
    },
      );
    }
  


export const getUpdateRoomMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext> => {

const mutationKey = ['updateRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoom>>, {id: number;data: Room}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRoom(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoomMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoom>>>
    export type UpdateRoomMutationBody = Room
    export type UpdateRoomMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a Room
 */
export const useUpdateRoom = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoom>>, TError,{id: number;data: Room}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoom>>,
        TError,
        {id: number;data: Room},
        TContext
      > => {

      const mutationOptions = getUpdateRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a Room by its ID
 * @summary Delete a Room
 */
export const deleteRoom = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteRoomResponse200>(
      {url: `/api/Room/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteRoomMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteRoom'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoom>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteRoom(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoomMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoom>>>
    
    export type DeleteRoomMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a Room
 */
export const useDeleteRoom = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoom>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoom>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteRoomMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a paginated list of SchoolYear with optional search
 * @summary Get paginated list of SchoolYear
 */
export const getSchoolYearPaginated = (
    params?: GetSchoolYearPaginatedParams,
 signal?: AbortSignal
) => {
      
      
      return fetchData<PaginatedSchoolYearResponse200>(
      {url: `/api/SchoolYear`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetSchoolYearPaginatedQueryKey = (params?: GetSchoolYearPaginatedParams,) => {
    return [`/api/SchoolYear`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSchoolYearPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = ValidationErrorResponse>(params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchoolYearPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchoolYearPaginated>>> = ({ signal }) => getSchoolYearPaginated(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSchoolYearPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getSchoolYearPaginated>>>
export type GetSchoolYearPaginatedQueryError = ValidationErrorResponse


export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = ValidationErrorResponse>(
 params: undefined |  GetSchoolYearPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearPaginated>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = ValidationErrorResponse>(
 params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearPaginated>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearPaginated>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = ValidationErrorResponse>(
 params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated list of SchoolYear
 */

export function useGetSchoolYearPaginated<TData = Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError = ValidationErrorResponse>(
 params?: GetSchoolYearPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearPaginated>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSchoolYearPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 *  Create a new SchoolYear with the provided details
 * @summary Create a new SchoolYear
 */
export const createSchoolYear = (
    schoolYear: NonReadonly<SchoolYear>,
 signal?: AbortSignal
) => {
      
      
      return fetchData<CreateSchoolYearResponse200>(
      {url: `/api/SchoolYear`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: schoolYear, signal
    },
      );
    }
  


export const getCreateSchoolYearMutationOptions = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSchoolYear>>, TError,{data: NonReadonly<SchoolYear>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSchoolYear>>, TError,{data: NonReadonly<SchoolYear>}, TContext> => {

const mutationKey = ['createSchoolYear'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSchoolYear>>, {data: NonReadonly<SchoolYear>}> = (props) => {
          const {data} = props ?? {};

          return  createSchoolYear(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSchoolYearMutationResult = NonNullable<Awaited<ReturnType<typeof createSchoolYear>>>
    export type CreateSchoolYearMutationBody = NonReadonly<SchoolYear>
    export type CreateSchoolYearMutationError = ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Create a new SchoolYear
 */
export const useCreateSchoolYear = <TError = ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSchoolYear>>, TError,{data: NonReadonly<SchoolYear>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSchoolYear>>,
        TError,
        {data: NonReadonly<SchoolYear>},
        TContext
      > => {

      const mutationOptions = getCreateSchoolYearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a SchoolYear by its ID
 * @summary Get a specific SchoolYear
 */
export const getSchoolYearById = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return fetchData<GetSchoolYearResponse200>(
      {url: `/api/SchoolYear/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSchoolYearByIdQueryKey = (id?: number,) => {
    return [`/api/SchoolYear/${id}`] as const;
    }

    
export const getGetSchoolYearByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = null>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSchoolYearByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchoolYearById>>> = ({ signal }) => getSchoolYearById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSchoolYearByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSchoolYearById>>>
export type GetSchoolYearByIdQueryError = null


export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = null>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearById>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSchoolYearById>>,
          TError,
          Awaited<ReturnType<typeof getSchoolYearById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific SchoolYear
 */

export function useGetSchoolYearById<TData = Awaited<ReturnType<typeof getSchoolYearById>>, TError = null>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSchoolYearById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSchoolYearByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing SchoolYear with the provided details
 * @summary Update a SchoolYear
 */
export const updateSchoolYear = (
    id: number,
    schoolYear: NonReadonly<SchoolYear>,
 ) => {
      
      
      return fetchData<UpdateSchoolYearResponse200>(
      {url: `/api/SchoolYear/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: schoolYear
    },
      );
    }
  


export const getUpdateSchoolYearMutationOptions = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchoolYear>>, TError,{id: number;data: NonReadonly<SchoolYear>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSchoolYear>>, TError,{id: number;data: NonReadonly<SchoolYear>}, TContext> => {

const mutationKey = ['updateSchoolYear'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSchoolYear>>, {id: number;data: NonReadonly<SchoolYear>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSchoolYear(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSchoolYearMutationResult = NonNullable<Awaited<ReturnType<typeof updateSchoolYear>>>
    export type UpdateSchoolYearMutationBody = NonReadonly<SchoolYear>
    export type UpdateSchoolYearMutationError = null | ValidationErrorResponse | InternalServerErrorResponse

    /**
 * @summary Update a SchoolYear
 */
export const useUpdateSchoolYear = <TError = null | ValidationErrorResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSchoolYear>>, TError,{id: number;data: NonReadonly<SchoolYear>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSchoolYear>>,
        TError,
        {id: number;data: NonReadonly<SchoolYear>},
        TContext
      > => {

      const mutationOptions = getUpdateSchoolYearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a SchoolYear by its ID
 * @summary Delete a SchoolYear
 */
export const deleteSchoolYear = (
    id: number,
 ) => {
      
      
      return fetchData<DeleteSchoolYearResponse200>(
      {url: `/api/SchoolYear/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSchoolYearMutationOptions = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSchoolYear>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSchoolYear>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteSchoolYear'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSchoolYear>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSchoolYear(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSchoolYearMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSchoolYear>>>
    
    export type DeleteSchoolYearMutationError = null | InternalServerErrorResponse

    /**
 * @summary Delete a SchoolYear
 */
export const useDeleteSchoolYear = <TError = null | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSchoolYear>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSchoolYear>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSchoolYearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
